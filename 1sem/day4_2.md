# 4 день. Теория алгоритмов, ДТ

## Словарик программиста:
- `Формализация понятия алгоритма` реализуется построением ***алгоритмических моделей***.
- [Машина Тьюринга](https://neerc.ifmo.ru/wiki/index.php?title=Машина_Тьюринга)
- ***Тезис Тьюринга-Чёрча***.
- ***Моделирование***.
- Моделирование говорит о том, что равенство алгоритмов есть равенство МТ

***

# Глава 2. Элементы теории алгоритмов

## 2.1 Необходимость формального определения алгоритма

Неформальное определение алгоритма не даёт понимания, как именно выполнять "всем понятные" действия.
> Легко ли описать словами завязывание шнурков?
> - Если вдуматься, это чисто механическое действие. 

Если бы все поставленные математические задачи могли быть алгоритмически решены, то не пришлось бы уточнять понятие алгоритма.

Для некоторых классов подобных задач не существует алгоритма решения, они называются ***алгоритмически неразрешимыми***.  
Доказательство того, что они неразрешимы, неизбежно содержит высказывания о всех мыслимых алгоритмах.
Но формулировка таких высказываний невозможна без формального определения алгоритма.

Формализация понятия реализуется построением ***алгоритмических моделей***. 

Рассмотрим 3 типа ***универсальных алгоритмических моделей***:
- рекурсивные функции;
- машины Тьюринга;
- Нормальные алгоритмы Маркова;

## 2.1.1 Рекурсивные функции

> © В Америке студенты пишут на lisp. Им устраивают таким образом дедовщину.
 
Рекурсивные функции были предложены в 30-ых годах прошлого века американским математиком Чёрчем (λ-исчисление).

В 60-ом американский математик Маккарти предложил интерпретируемый алгоритмический язык Lisp, также основанный на λ-исчислении.

На λ-исчислении основывается идея функционального программирования.

***

## 2.1.4 Тезис Тьюринга-Чёрча

Использование алгоритмических моделей опирается на тезис Тьюринга-Чёрча о том, что
`всякий интуитивный алгоритм может быть выражен средствами одной из алгоритмических моделей`.
> Тезис не был опровергнут, но и не был доказан. Поэтому и называется `тезисом`.

Алгоритмические модели описывают один и тот же класс процессов обработки сообщений.

Доказано, что одни модели сводятся к другим, т.е. могут быть описаны средствами других моделей.

Модель Тьюринга выберем для формализации понятия алгоритма, т.к. она ближе всего в вычислительным машинам.

***

## 2.1.2 (+ 2.2) Машины Тьюринга

В 1936 г. Алан Тьюринг для уточнения понятия алгоритма предложил абстрактную вычислительную машину с простым набором операций.

`МТ расшифровывала криптограммы фашистов, что имело высокое значение в годы Второй мировой войны (машина enigma)`

МТ состоит из ограниченной с одного конца бесконечной ленты, разделенной на ячейки,
и пишущей головки, которая может перемещаться между ячейками.

![image](https://user-images.githubusercontent.com/113284506/211057457-072a7932-c53f-4e9f-9da6-8dd4a5a59720.png)


В каждой ячейке может быть записан один знак рабочего алфавита либо пробел (лямбда).

Головка МТ располагается над одной из ***рабочих ячеек*** ленты и воспринимает знак на ней.
При этом головка находится в одном из ***дискретных состояний***, среди которых выделено начальное состояние q0.
В зависимости от рабочего состояния и от буквы в ячейке МТ выполняет одну из ***команд***, составляющих ее ***программу***.

Выполнение команды состоит в совершении действия и в переводе головки в новое состояние (может совпадать со старым).
Есть три вида элементарных действий: сдвиг на ячейку влево, вправо и запись буквы/пробела.

Перед работой МТ на ленту записывается исходное сообщение в ячейки побуквенно, при этом длина сообщения и число ячеек конечны.
Ячейки справа от последней буквы исходного сообщения считаются пустыми.
     

- Работа МТ полностью определяется её программой и сообщением, которое было записано на ленте перед началом работы МТ.

 Команда МТ описывается ***упорядоченной четвёркой*** символов `(q, a, v, q')`.
 - `q` - текущее состояние головки; 
 - `a` - буква в рабочей ячейке;
 - `v` - выполняемое действие;
 - `q'` - новое состояние.
  
![image](https://user-images.githubusercontent.com/113284506/210623479-855a221b-6d84-4dda-8284-dbcb4e4cc6a3.png)


***

2.2 Математически строгое определение МТ (`можно и без него обойтись`)

 
![image](https://user-images.githubusercontent.com/113284506/210616485-5355111d-d03d-4c99-8002-27eb3b254f5c.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616568-5c4b3a4a-cb90-49a3-a49f-808f5d875ea7.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616591-4b91e4eb-1269-42a8-b9e5-d3f598f6c4a0.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616671-d5e82dc5-2499-4912-9d49-d39181f197c6.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616692-2afd9df0-dea4-49bb-8d13-7797e500a72d.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616726-d3dd16c0-1e21-4de6-ba32-d09ddcbc0d8a.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616750-494bb7dc-7ba9-4464-bd54-3eb2ec1fe85d.png)
  
![image](https://user-images.githubusercontent.com/113284506/210616805-3413c782-e1e1-4f65-9a5e-0dbde9b31715.png)


> Нам важно объяснить, какие моменты в Тьюринге не годятся для актуальных алгоритмических систем.

- Даже простые действия на МТ выполняются сложными программами.
- Кроме того, запись программ МТ в виде таблиц плохо обозрима и неудобна для понимания.
- Поэтому перейдём к диаграммам!

***

## 2.2.3 Диаграммы Тьюринга

В результате критики Тьюринга предложили диаграммы Тьюринга (5 лабы - низкоуровневое, сложное и неудобное программирование).

> - © Диаграммер и МТ задают культуру программирования.
> - © Это даже полезнее, чем на ассемблере.
> - © А решение задач на питоне не выигрышно по времени и по памяти.

- Диаграмма Тьюринга - попытка создания удобной схемы программирования для человека (более удобной, чем машинные кода).

> Любая программа выразима с помощью диаграммы, и наоборот. 

***

Диаграммы представляют одни МТ через другие, более простые, при этом другим визуальным способом и без потери в строгости.
- Описание МТ сводится к ***элементарным действтиям***, введённым при определении МТ.
- `Элементарная МТ` выполняет одно элементарное действие и останавливается, при этом не может быть описана проще.
Виды элементарных МТ:
- машина r - сдвиг на ячейку вправо;
- машина l - сдвиг на ячейку влево;
- машина λ - запись знака на ленту.

Комбинация нескольких одинаковых элементарных МТ `l` и `r` даёт машины `L` и `R` соответственно.
- `L` - сдвиг в левый конец слова;
- `R` - сдвиг в правый конец слова.

ДТ рисуется слева направо сверху вниз, будучи ориентированным на человека вариантом алгоритмической модели Тьюринга.
> В диаграммерах этот принцип сохраняется.
> - Диаграмма Тьюринга - это алгоритм (от неё буквально один шаг до программирования).
- JDT - наш ява-диаграммер!
- **Диаграммер VTM - требует Qt (есть на faq8).**

- Состояния на диаграммерах обозначаются точками, каждый символ на диаграмме обозначается ***между двумя точками***
- Т.е. вот так:  `.R.`

Если после действия одной машины должна быть выполнена другая, соединяем их стрелками. Над стрелками надписываем знаки, определяющие переходы.

![image](https://user-images.githubusercontent.com/113284506/210620180-e3d4f0e1-b244-4f0c-8a19-1274f299e764.png)

***

***Пример НЕ алгоритма.***

![image](https://user-images.githubusercontent.com/113284506/210620349-513c0b57-14a0-4ba7-958b-bcef47224d00.png)

***

Для повторения участка диаграммы ***нужно его замкнуть***.

![image](https://user-images.githubusercontent.com/113284506/210620603-ee34cc96-8fdc-43b1-bc28-2319dffbe6da.png)

Для упрощения диаграммы ***можно опустить некоторые стрелки и подряд идущие машины***, записав их число в виде степени машины.

![image](https://user-images.githubusercontent.com/113284506/210620848-1a4a941c-4778-4cff-8e50-715534145d7d.png)

***

`Примеры диаграмм.`
  
  ![image](https://user-images.githubusercontent.com/113284506/210620964-1b4a5a26-c18e-40f4-a15f-b676ac7e2e39.png)

  ![image](https://user-images.githubusercontent.com/113284506/210620993-f44b62f3-81bd-4143-9b4e-b61b338d9d11.png)

***

## 2.2.4 Понятие моделирования

***

Тут сложно. `Ниже будет короче.`
  
  ![image](https://user-images.githubusercontent.com/113284506/210621256-c64bc00f-62ce-4bb2-81c1-e412c752a20c.png)

  ![image](https://user-images.githubusercontent.com/113284506/210621278-d0e95ad0-1460-496d-8aa2-b89a6835e1f2.png)

  ![image](https://user-images.githubusercontent.com/113284506/210621318-83ca4b60-3cd5-41fa-9d66-0a692c25ad05.png)
  
***

> Главное запомнить идею о том, что всё связано с понятием отображения и образа. 

`Определение 2.2.5` Машина Т моделирует другую машину, если выполняются 5 условий:

1) Указан способ кодирования знаков;
 
2) Для каждого состояния машин определено отображение из множества состояний Q в Q';

3) Если С0 — начальная конфигурации (*положение*) первой машины, то её образ C0' есть конфигурация (*положение*) для второй машины.

4) Машина А останавливается в некотором положении Ck, тогда машина А' останавливается в положении  Ck', где Ck' — образ Ck.

5) Машина А проходит последовательность конфигураций такую, что для машины A' последовательность пройденных конфигураций тоже будет образами. 


Если одна машина моделирует другую, то она описывает тот же алгоритм, но может проходить большее число промежуточных конфигураций.
Понятие моделирования вводит бинарное отношение алгоритмического равенства между машинами Тьюрингами.
> Т.е. понятие моделирования говорит о том, что равенство алгоритмов есть равенство МТ.

***

## 2.2.5 Эквивалентность диаграмм и программ

`Теорема 2.2.6` Каждой программе, задающей МТ `Т = (A, Q, P, q0)`, можно эффективным образом сопоставить диаграмму `D` так, 
чтобы диаграмма моделировала машину `Т`.

> Нам надо указать алгоритм эффективного построения диаграммы по программе, а потом убедиться в соответствии предыдущей формулировке.
```yaml
План доказательства теоремы:
```

1) Построение диаграммы.

2) Проверка условия определения `2.2.5`.


`Теорема 2.2.6. Доказательство:`
  
  ![image](https://user-images.githubusercontent.com/113284506/210626824-c00dc7e0-811c-4b7b-9d35-418f22cdab1e.png)

  ![image](https://user-images.githubusercontent.com/113284506/210626909-c4eaec0f-8478-4d07-89b0-2d0f9a96d11c.png)

***

`Теорема 2.2.8 (обратная)` Каждой диаграмме может быть эффективным образом составлена программа так, что она моделирует диаграмму.  

```yaml
Доказательство в 2 этапа:
```
1) Построение программы.

2) Проверка условий определения `2.2.5`.


`Теорема 2.2.8. Доказательство:`

  
  ![image](https://user-images.githubusercontent.com/113284506/210627100-01a26fc8-130a-4191-a09d-7b4ddea6892a.png)

  ![image](https://user-images.githubusercontent.com/113284506/210627148-e810e488-c768-4e01-9544-75632c32a84f.png)
  
  ![image](https://user-images.githubusercontent.com/113284506/210627206-56d568c3-5ed4-4384-9f6b-96a47416f736.png)


***

## Что покрывают диаграммы (какие цели):

- Диаграмма Тьюринга - это алгоритм (от неё буквально один шаг до программирования).
- Исходные ***сообщения*** задаются в виде ***слов***, а ***лента*** - это ***память***.

> Вычисления должны быть нормированы!
> При этом МТ не использует дополнительных букв.

`Если алгоритм - это МТ, то равенство алгоритмов означает равенство МТ.`

> Тьюринговская теория позволяет сравнивать 'мощность' алгоритмов.
> - Но сравнивать мощность **не совсем корректно**. Мы сравниваем именно **вычислительную (алгоритмическую) сложность**.


- Почему нельзя склеить кусочки программ из диаграмм?
- Потому что в программах есть уникальные номера состояний, и если их не согласовать, то программы будут конфликтовать. 



