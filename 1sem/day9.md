# 9 день. Архитектуры компьютера. Вопросы 1-12.

## Здесь вся статья — сплошной словарик программиста

Рекомендую в дополнение к нашей статье:
- [1 ресурс](https://studfile.net/preview/4216687/page:2/)
- [2 ресурс](https://arch32.cs.msu.ru/Text/Chapter_02.pdf)
- Сравнение [двух архитектур](https://studfile.net/preview/6408636/page:16/)

## 1 вопрос. Понятие об ЭВМ

`ЭВМ` — электронная машина ***для вычислений***.

- Этот электронный прибор называют машиной, потому что в нём много составных частей.

***Структурная схема:***

![image](https://user-images.githubusercontent.com/113284506/210811694-ea629dd8-3c50-47cd-8053-5035bb44f21f.png)

- Как видно из рисунка, машина фон Неймана состоит из памяти (memory – этот
термин впервые введён фон Нейманом!), устройств ввода/вывода и центрального процессора (ЦП).
- Двойными стрелками показаны потоки команд и данных, а одиночными — передача `сигналов` между отдельными устройствами компьютера. 



> Дальше затрагиваем смежную тему, чтобы показать кругозор.
> - А вот телефон, к примеру, содержит всё это в одном корпусе `(можно здесь добавить немного о телефоне, сравнив с компьютером)`.

***

## 2 вопрос. Принципы фон Неймана 

Аппаратная реализация процессора фон Неймана — это `машина`.

***Различают 3 принципа:***

1) ***Принцип программного управления***
- Алгоритм работы программы представлен в виде последовательности команд.
- `Команда` — управляющее слово, предписывающее некоторую доступную к выполнению операцию.


2) ***Принцип адресности***
- `Основная память` состоит из пронумерованных ячеек, и процессору в любой момент доступна любая ячейка памяти.
- В этих ячейках информация хранится в виде двоичного кода. Содержимое ячейки называется `машинным словом`.
- Двоичная система счисления позволяет хорошо описывать архитектуру узлов ЭВМ с помощью булевских выражений.

> - `Машинное слово` — минимальный объем данных, которым могут обмениваться между собой узлы машины.
> - `Бутылочным горлышком` машины фон Неймана является тот факт, что за раз можно обменяться с памятью только одним машинным словом. 

3) ***Принцип однородности памяти*** (или принцип хранимой в памяти команды, первый по важности!)

- `Память компьютера универсальна`. В памяти `неразличимо` друг от друга хранятся данные и программы.
- В зависимости от способа обращения к ячейке памяти одно и то же значение может использоваться и как данные, и как команда.
- Время чтения и записи в любой ячейке одинаково, но два этих времени могут не совпадать.

Фон Нейман — Принстон. Известен благодаря своему 3-ему принципу.
> А чем эта структура (принстонская) так хороша?
> - В чём `принстонская` архитектура проигрывает `гарвардской`? Это надо проанализировать в ответе.
> - А где используется гарвардская архитектура?

- В гарвардском вирусы посложнее, так что это не спасение от гибкости фон Неймана (и плюс, и минус). 

- Сравнение [двух архитектур](https://studfile.net/preview/6408636/page:16/)

- `Канал` — это специализированный процессор ввода/вывода. В канале есть процессор и память.
- Он распараллеливает процессоры, фактически делая компьютер многопроцессорным.

```yaml
Канальная архитектура (?важный вопрос, изучи!)
```

***

## Вопрос 3. Структурная схема класса Mainframe. 

- `Фирма IBM` — известна благодаря байтам и ASCII (придуманы там). 
- В том числе известна благодаря семейству компьютеров IBM 360.

В те времена `(эпоха mainframe)`связь шла через телефонные линии.
- В эпоху mainframe компьютеры начали выпускать уже массово, ради денег.

***

## Вопрос 4. Открытая шинная архитектура. Системная плата.
`Шина компьютера` — информационная магистраль, вокруг которой строится компьютер.
- Это открытое устройство для соединения, аппаратного расширения, в отличие от замкнутой аппаратуры мэйнфрэймов.
- Шина ставила устройства в равноправное отношение.
- Шина — магистраль обмена данными.

Через адреса, которые есть в шине, можно обмениваться между устройствами.
> Шина является к нам в форме материнской платы.
> - Но по факту `все устройства втыкаются в шину`.

`Материнская плата` — это кусок текстолита.

- ***Северный и южный мосты*** — это чипы, которые обеспечивают работу материнской платы. 
- `Северный мост` — работа процессора с оперативной памятью и GPU.
- `Южный мост` — медленная периферия, мелочь всякая.

До шины гибкости в компьютерах не было! Шину придумали для миникомпьютера, микропроцессора.
- При этом она была быстрой!

- `pdp11` — 1976 год, 16-ти разрядные мини-ЭВМ фирмы DEC.
- `Фирма DEC` — Digital Equipment Corporation, основана в 1957 году.

Лучше шинной архитектуры ничего не придумали. 
> Далее вслед за DEC в эту сферу втянулась и фирма IBM со своим IBM PC, вышедшим в 1986 году.

***Недостатки шинной архитектуры:***
- Сначала шина была узким местом. Она начала тормозить.
- Тогда сделали отдельную шину процессора и отдельные шины для видеокарт.

Шине не позволили стать узким местом компьютера — поставили доп.шину и всё! Не надо менять ни программиста, ни драйвера!

> Какая архитектура у смартфона? Хороший вопрос!

> - Разъём Ethernet — хороший вопрос!

***

## Вопрос 5. Процессор. Регистры. УУ и АЛУ.

`Процессор` — это главная центральная обрабатывающая часть компьютера. 
Это ***полупроводниковый чип*** (важное замечание!), который нанесён на кристалл, работающий в соответствие с нанесённой на него схемой.
> Процессоры печатают, как деньги!
Процессор работает на `машинном языке` — языке команд процессора!

***Процессор состоит из:***
- устройства управления `(УУ)`
- арифметико-логического устройства `(АЛУ)`

- `АЛУ` — это конкретная реализация всех программ. Процессор выполняет команды из АЛУ.
> Чтобы было понятнее: ***АЛУ*** — это 100 машин Тьюринга.
- `УУ` — управляет процессом выполнения команд.
У каждой команды есть операнды.

- `Регистр` — служебная часть памяти внутри процессора.

При чтении копия машинного слова читается из ячейки памяти и записывается на регистр,
а при записи копия машинного слова с регистра посылается в ячейку памяти.

РК, РАК, РД, РАД — ***лежат на ЦП***.

- `РК` — регистр команд, а `РАК` — регистр адреса команд.
- `РД` — регистр данных, а `РАД` — регистр адреса данных.
> Сейчас поясним.

По принципу фон Неймана выполнение идёт команда за командой, при этом команда находится в оперативной памяти.

`РАК` указывает на команду в памяти и загружает команду в `РК` — на центральный процессор.
- ***Операнды*** идут в регистр данных.
- Команды и данные отдельно!

Вычисление адресов — непростая штука. Часто они формируются динамически. В этом процессе фигурируют регистры (их номера), где содержатся записи адресов.
- То, что вычислили, загружается на регистр данных. Получается гарвардский регистр.

Получается, что адреса регистра данных и команд лежат отдельно. 

```yaml
© мухи отдельно, котлеты отдельно
```

Чтобы данные стали командой, они должны попасть на спец.регистр. 
> Поэтому `мусор` никогда не станет командой. Спец.регистр не пропустит.

- Регистры, доступные программистру — лишь арифметические!

```yaml
© Машина фон Неймана 
- это чаша для существования вирусов.
```

РАК накручивается на длину выполненной команды. Команды выполнятся одна за другой.

Команда перехода подменяет место, где будет совершён переход.

> Взаимодействие процессора и памяти.
> - Посредник в чтении данных — регистр. Напрямую данные не читаются.

РАК и РК — активные данные.

И хотя программисту доступны лишь арифметические регистры, он при этом может химичить с памятью: подготовить зловредную версию программы и подменить её!

РАК, РК, РАОП, РДП — недоступны программисту.

Внутри процессора гарвардская архитектура!

> Как видно, вопросы связаны. Наша задача на экзамене — составить лаконичный рассказ, затронув смежные темы.

> - Каждый процессор внутри всегда `гарвардский`!
> - а снаружи?.....

Назначение регистра: процессор благодаря нему всегда знает, где идёт команда.

- Всё идёт через РАК и РАД `(всё идёт через регистровые адреса, так запоминаем)`
- РАК читает, РАД — читает и пишет!

Процессор выполняет свои железные, зашитые в ПЗУ команды.

```yaml
(зашитые немками из фирмы Siemens)
```

`Микропроцессор` (1951) (Вилкс) — эта железка выполняет сдвиги, ссылки, но не вычисления.
- Это увеличило гибкость процессора программирования 
> (по сравнению с чем?)

> - Знаменитые ошибки процессоров (?) (надо узнать)

- Раньше процессоры были дискретными. (?)

***Что представляют собой ядра?***
- `Ядра` — это несколько аналогичных процессоров на одном кристалле, чипе.
- `Потоки` — это *недопроцессоры*, они позволяют распараллелить выполнение команд. При этом ***потоки имеют функцию ожидания завершения процесса***, `поэтому` они неполноценны.

- AMD придумали контроллер памяти в процессоре (но их обвинили в воровстве у DEC).

- Intel лицензирует фирме AMD свои процессорные команды. Хотя AMD имеет немного другие команды.

- `Микропрограммная реализация` обеспечивает гибкую настройку компьютера.
- За счёт неё компьютер железный (огромный, размером с комнату) упростился до уровня команд.
- Микропрограммы подражают командам, разработанным на полноценном ПК.

> Универсальная машина Тьюринга — идея компьютера от Тьюринга как самостоятельной управляемой единицы.

***

## Вопросы 6-11. Архитектуры процессоров

- `CISC` — Complex Instruction Set Computer — компьютер с набором сложных команд.

CISC читается как КИСК, а не циск.

Зачем нужен сложный набор команд? Чтобы работать с `железным` железом, когда программирование было на ассемблере.
(На компьютерах, прошитых нитками немецких тружениц фирмы сименс.)

- `Цель CISC` — обеспечить людей готовыми командами программирования для различных целей, в том числе для физики, математики.

Дальше шло усовершенствование железок. Первым, что сделали — ввели `косвенную адресацию`.

`Косвенная адресация` нужна для сокращения длины машинных команд (`адрес` - машинное слово).
Адреса в памяти заменялись короткими номерами регистров.

1 регистр — полбайта, значит, сокращение вышло в 8 раз.

Таким образом экономилось место на ОЗУ и на самом жёстком диске.

- `Прямая адресация` — номер-номер. Кроме того, приплюсовывается номер регистра.
- Он же даёт + полбайта, зато происходит `индексация` — второе введение.

Таким образом обрабатываются массивы.

> Читаем про обработку массивов.

Благодаря косвенным схемам адресации вместо нескольких десятков команд получилось несколько сотен команд.

> Косвенная адресация, индексация, базирование — это ищем!

`Базирование` позволяет хранить и запускать программу вне зависимости от настроек команд.

Индекс образуется на лету. Это было нужно, чтобы ускорить работу пк.

- Компьютер VAX-11 (фирмы DEC) имел порядка 300 команд, это была мечта советского программиста.
- Он использовался в авиации.

> `АЛУ` — арифметико-логическое устройство

***
***RISC***

- В 70-ых возникла проблема: стало сложно повышать производительность ПК. Причина — сложность архитектуры CISC.
- В 1984г. было предложено убрать тупиковый CISC. Фирма IBM не любила C, Pascal, а любила свои Cobol, Fortran.

> - © А у меня вот полином есть — так говорили конструкторы VAX

```yaml
- А зачем нам ассемблер?
- Даже негры на нём не работают!
```

Тем более, зачем делать CISC, если на асемблере никто не работает и если есть язык C, который быстрее.

> © И на котором даже пишутся драйвера видеокарт!

Тогда предложили новую архитектуру — RISC! Уже тогда перестали экономить на памяти. Дефицит памяти пропал, и многоуровневая косвенная адресация стала не нужна. 
При этом программистам на асемблере платят столько же, сколько и на C, но as-шников нужно больше на один проект, что невыгодно.

> © Эра удобного вычисления полинома на асемблере уже прошла!


`RISC` предложена фирмой IBM. 
- Эта архитектура разбухла в 3-4 раза в размерах программ (у нас плоская память и большой набор команд), процессор стал мощнее на порядок.
- Выигрываем в весе! А команды имели фиксированную длину!

`Плоская память` — от нуля и до (большого числа). Косвенная адресация режется на кусочки и кладется друг на друга. 

CISC у фирмы Intel имел высокое распространение и дешивизну, но как пропихуть RISC в массы?
- Продавая CISC, в Intel понимали, что это неудобно, хоть и приносит деньги.
- Тогда они сделали в своих процессорах тайное RISC-ядро, т.е. ввели промежуточный уровень.

RISC стал внутри, на уровне микропрограмм.

1) RISC-ядро
2) II поколение RISC (64 бита)
3) RISC-32 бита — простая архитектура, используемая в роутерах.
> эту информацию стоит изучить подробнее

***Остановимся на RISC II поколения (1991г.)***

Это процессоры серверного типа, но на одном чипе. 

> Почему на это дело ушло почти 10 лет? (вспоминаем, что только в 1984 предложили сменить CISC)

Мы говорили о плоской памяти, о том, что адресация не содержит нелинейности. В то время были 32-битные процессоры.

`32-битный процессор` — тот, который ***за один такт*** обрабатывает 32 бита.

Если бы компьютеры не развивались, программы были бы рыхлые (за счёт командных слов).

***Как появились 64-битные процессоры:***

32 бит может адресовать 2 ГБ. Адрес памяти тоже должен быть 32-битным.

> © 32-битный процессор — это `кухонный` процессор. Он нам не годится.

***

***MIPS***

`MIPS` — Million Instructions Per Second (процессор R-10000).
- Процессоры MIPS были первыми RISC-процессорами на 64-битной архитектуре!
- Это процессоры серверного типа.

RISC отличается большим количеством регистров.

Придумано переименование регистров на ленту. Переименование регистров позволяет быстро переключаться в *контексте* регистров (обмениваться).

DEC — ALPHA (64 бита). Хотели занять весь серверный рынок.


> © Процессорные фирмы не делают процессоры! Они делают деньги!

- RISC проник в CISC.
- IBM POWER PC — пример RISC 2 поколения 

***

***VLIW***

`VLIW` — Very Large Instruction Word (очень широкое командное слово).
- Intel почти примкнул к Vliw, чтобы тоже делать 64-бит.
- Но Intel вместе с Packard потерял деньги впустую.

> Поищи провалы Intel.

`VLIW` — это тоже попытка серверного процессора, но не вышедшая в массовом тираже.

***

*SISD* `(в вопросах SISD нет)`

`SISD` — Single Instruction - Single Data.
- Не является общепринятой. 1 команда — одна единица данных.

Далеко не всегда удобно сводить к линейным системам (много памяти, большая погрешность при этом).

Когда 1 единица данных на 1 команду, линейная алгебра этого не терпит.
Наша линейная алгебра хочет SIBD.

***

***Векторно-конвейерная архитектура***

***Появилась векторизация*** (нужно было выяснить, как вектор представить в скалярном виде).
Одна часть вектора на регистре, а другая считался в памяти.
- Векторизация считала большие данные на суперкомпьютерах (Control Delta Corporation — CDC 6600).
> Моделирование ядерных взрывов, нейтронных бомб, прогнозов погоды.

`Крей` - автор идеи `внутреннего распараллеливания` (операнды можме загружать параллельно, одновременно).
- Параллелизм даже в последовательно написанной программе имеет место быть (например, `конвейер команд`!)

> Процессор Alpha имел 10 конвейеров, т.е. он в 10 раз быстрее себя одного.
> - Но Intel всё равно победил в бизнесе, в итоге заработано больше денег, и они сейчас на слуху.

`Конвейер` распараллеливает за счёт нового/дополнительного оборудования.
- В настоящее время конвейеризация пошла в сторону thead'ов (потоков).

***

***Транспьютеры***.
`Транспьютер` — способ сделать вычисления из простых процессорных элементов. 
С помощью них брали изображение, клали в радилокационные яипы, и при помощи компьютерного зрения устанавливали точность изображения (с самолётов).
- Сейчас эти задачи осуществляются с помощью видеокарт.

***

***DSP***
- `DSP` — Digital Signal Processing — цифровая обработка сигналов.
> И что особенного в этом сигнале?

Это переменные данные, вещественная прямая континуального характера.
- `Сигналы`— это как переменные токи. Переменные токи дискретно преобразуются в двоичные числа, которые можно обработать процессором.
- DSP — это цифровая версия аналогового компьютера. Сейчас аналоговые компьютеры сохранены на уровне приборов.

DSP нам нужны, они никуда не уйдут. Взять хотя бы слух — он у нас аналоговый, не цифровой.
- В конце любой цифровой колонки/наушников стоит аналоговая мембрана.
- Она контролирует процесс аудиотракта.

> © Нормальные люди никогда не пишут на железной машине ассемблера.
> - Это всё равно, что есть необработанную пищу или есть бесформенную одежду.

```yaml
© Машина фон Неймана приходит к нам в виде ЯП
```

***

## Вопрос 12. Выполнение программы ЭВМ

Чтобы программа была выполнена, компьютер должен иметь её в `основной памяти` (или безграмотно — в ***оперативной***).

Память называется основной, потому что она главнейшая в компьютере. В ней одновременно хранятся данные о нескольких программах, готовых к выполнению.

- `Оперативная` память = `операбельная`, а термин операбельности применим к древним железкам времён Адама и Евы.

Если машина в работоспособном состоянии, то в ней есть ОС, обрабатывающая внешние устройства.

А если компьютер выключен, то в его процессоре и в оперативной памяти ничего нет. 
И в момент включения нет ничего.

> Тогда нужна какая-то программа, которая всё это дело запустит!

Здесь, по аналогии со шнурком, который при натяжении развяжет ботинки `(вспоминаем технологию бутстрепинга)`, используется программа начальной загрузки IPL.

- `IPL` — Initial Program Load, или загрузка начальной программы.

```yaml
© Английским владеют даже тупые англичане!
```

- Подробнее про IPL [можно прочитать здесь](https://ru.bmstu.wiki/IPL_(Initial_Program_Load))

Но мало включить компьютер. Надо подсунуть ему мелкую программу.

Если бы этого не было: надо было бы на тумблере с лампочками набрать нули и единицы, затем загрузить команду и отправить.
Но это не автоматизм.

Нам нужна ОС, которая может откуда-то получать программы и автоматически выполнять их.

***Пример выполнения программы включения:***
1) Программа попала в пульт. Но пока что это мертвые данные.
2) ОС узнала адресочек команды. Чтобы адрес с данными `РАД` стал командой, надо загрузить её на `РАК`.
3) Процессор выполняет циклограмму (повтор итеративной программы).
4) Компьютер разменивает данные, и команда попадает на регистр команд.
5) На регистре `УУ` дешифрует адрес команды. Она выясняет, мусор ли это, проверяет правильность.
В случае правильности дешифровка продолжается, иначе комп выдаст ошибку или остановит дешифровку.
6) У команды есть операнды, но на железе хранятся адреса.
7) Давным давно расшифровка попадала не на регистры команд, а на регистры данных.
8) УУ запускает микропрограммы, АЛУ выполняет уже то, что находится на регистре.

- Раз то, что на регистре, является копией, то эти данные не хранят в памяти. Но если мы хотим запомнить их, то введём данные вручную.
- Когда данных мало, они должны оседать на регистре (это быстрее).
- На оптимизирующих компиляторах должно быть так, как описано строчкой выше.

Пример:

C = a + b

1) Разыменовываем a
2) Разыменовываем b
3) Выполним микропрограмму сложения
4) Делаем запоминание/запись в С

