# 12 день. Файлы, блоки

## Словарик программиста (надо знать!):

- `Запись` — комбинированный ***структурный тип*** с квалифицированным доступом.
- `Подпрограмма` — именованный фрагмент программы, предназначенный для выполнения специальной инструкцией обращения.
- `Структура файла` — обобщение понятия последовательности.
- `Файл` — это НЕ МАССИВ НА ДИСКЕ! Это ошибка!
- `Перемотки` — один из методов обработки **длинных последовательностей** (файлов, иначе говоря).

***

```yaml
© Снег выпал...
- Уже погуляли, надо возвращаться!
```

***

### Лирическое отступление

> - К какому множеству относится литерный тип?
> - Повтори схему описания типов!
> Если о вещественном типе сказать только, что это float или double, то ничего хорошего можно не ждать!

> Схема: множество значений, изображений, интерпретаций

***

### 3.2.10 Понятие о записях

- [Можно почитать здесь](https://studfile.net/preview/2238048/page:25/#53)

- `Запись` — комбинированный ***структурный тип*** с квалифицированным доступом.
- `Комбинированный` — значит, что поля записи имеют различные типы.

Квалифицированный доступ, в отличие от индексированного, негибок и невычислим, т.к. требует явного указания
статически определённых до компиляции имён полей, но это компенсируется большой семантической нагрузкой этих имён. 

Здесь мы вручную с каждым компонентом записи должны работать.

> © Нельзя решить проблему за раз, спустив курок.
> - С ней надо разделываться постепенно.

Нельзя сказать, что запись — долгий процесс, просто он не автоматический.
Это компенсируется большой семантической нагрузкой: программист не забудет, что он написал.


> Записи неудобны для регулярной обработки, но они несут в себе смысл, и ты не перепутаешь переменные даже через неделю.

© Мнемоника нужна сегодня, чтобы не ошибиться, и завтра, чтобы не забыть, что вы написали.

- В ***структуре*** иерархия!
- В массиве она неестественная, ненатуральная.

Дата рождения — субструктура, поля которой более очерчены.

![image](https://user-images.githubusercontent.com/113284506/211161850-ce1881a8-ed48-4135-a255-6e2aa649df90.png)

![image](https://user-images.githubusercontent.com/113284506/211161859-711d6e23-4d3a-45cf-9a16-180ddf4765bd.png)

![image](https://user-images.githubusercontent.com/113284506/211161868-b1b81e1c-0e0d-4052-8299-cec695a29e15.png)


![image](https://user-images.githubusercontent.com/113284506/211161875-360fe896-2c91-4a35-8638-229ae22a0597.png)



Вариантные записи позволяют обойти типовую безопасность.
На примере девятки рассмотрим разные типы данных:
- True — булевский
- 9 — 9 (Char)
- 9 — 57 (Код ASCII) (И какой это тип?)
- 9 — 0,00000+e00 (Вещественный)

У каждого из этих типов своя алгебра, свои отношения и значения.

Булевский: все нули (False), хотя бы одна единица (True).
А по целому? Определяем, дополнительный ли этот код (по первому числу)

Как видим, 4 типа совершенно разной интерпретации.

***

### 3.2.11 Понятие о файлах

Файл надо обрабатывать совсем по-другому.

```yaml
- У нас негласный запрет
- на обработку файлов через массивы
```

> © Самый маленький файл всегда больше самого большого массива.

***Файл*** — обобщённая последовательность (из математики).
- `Структура файла` — обобщение понятия последовательности.

- Массив — доступен за постоянное время
- Файл — доступен за линейное время

> Размеры файлов велики, но при этом конечны.
> Файлы надо постепенно прочитывать.

Обращение к диску содержит 2 действия за линейное время и одно движение за постоянное время.

> Торможение, движение назад всегда медленнее движения вперёд, потому что назад нельзя двигаться (инерционные законы Ньютона, правила электро-механики).

`Считаем, что файл — мгновенная лента.`

> В методичке сказано, что "файл — массив на диске".
> - `Это ошибка, ловушка для шпиона!`
> - Не следует загонять файлы в массивы!

`Допущение таких ошибок показывает безграмотность.`
- А ещё файлы потенциально бесконечны.

> Все компоненты нельзя заносить в файл, можно лишь какую-то часть — четверть нельзя!

Строку текстового файла хранить опасно.
Файл в 1мб не поместится в буфер одной строки.


***Перемотки*** — один из методов обработки **длинных последовательностей** (файлов, иначе говоря).

***

Файлы принято подразделять на: внешние и внутренние, текстовые и нетекстовые, входные и выходные.

***

### Внешние файлы

Внешние файлы перечисляются в заголовке программы.

Время жизни именованных файлов ***шире*** времени жизни ***программы***.
- Она стирается сразу `после использования`, но не файл.

Именование файла должно сопоставляться и с Unix, и с языком СИ!
Это важно!

> Кто сопоставит имя файла на pascal с Unix?
> - Обычно это делает **динамическое сопоставление**, в момент ***runtime***.
> - Не компилятор!
> - Это делает `языковая среда` во время `runtime`!

Файлы медленны в доступе и в работе, зато они долговременны, и хранить их в оперативной памяти дороже.

> Сам прикинь стоимость жёсткого диска и оперативной памяти.

К тому же, оперативной памяти всё время нужно электричество, чтобы в ней что-то хранилось, а файл может годами лежать на жёстком диске.

***

### Внутренние файлы

Внутренние файлы описываются в программе как файловые переменные. 
Их время жизни равно времени работы программы или короче (при динамическом сопоставлении).

- Внутренние файлы используются в качестве временной памяти.

***

### Текстовые файлы

***Текстовые файлы*** — файлы из литер, универсальный тип для ввода-вывода данных.

Они сами по себе полезны: у них есть строки, причём строки переменной длины.

- Не все догадываются, что длина строки может быть нулевой.
- А это одна из тонкостей!

Нетекстовые — это не файлы литер.
Они хранят данные как значения во внутреннем  

`Т.е. не как код ASCII, а как код в машинном виде.`

Это данные, снятые с датчиков.
- Они не предназначены для прямого восприятия человеком.
- Они не для человеческого уха или зрения.
- Они предназначены для плеера, или для устройства воспроизведения.

> И правда, двоичный машинный код мы можем понять лишь через представление в устройстве, аппаратную реализацию. 

При вводе-вывод сканируем код по схеме Горнера за линейное время, и при этом экономим время, но усложняется сам процесс компиляции.

***

### Временные файлы

Они не имеют глобальных имён.
Используют файл, чтобы писать в массив.

Не зарегистрированы в ОС как долговременные.
Могут вообще даже никогда не быть открытыми.
При этом работают быстрее программы.

Их имена всё же создаются Unix`ом в виде 'SYSnumber', но это наименование временное.

Файлы:
- внешние и внутренние
- текстовые и нетекстовые


Треть — процессор, треть — кэш, треть — вещественный тип.

> Как исправлялись бракованные процессоры Intel?
> - Патчами в Bios.
> - А вот процессоры фирм DEC и IBM не ломались!

***

Какое отношение всё вышесказанное имеет к массивам?

Вектор коэффициент - многочлен проще задать в компьютере именно так. Потому сами многочлены не годятся для вычислений математики из-за больших погрешностей.

```
© Когда я не был женат,
- мог себе позволить раскрывать определитель
- матрицы многочлена 11-степени 3 месяца!
```

> Степень многочлена может быть от 0 до 10.

`Напечатать многочлен — изящный довес к программе.`

Невыгодно числа хранить в текстовом виде.
А также проблематично вводить и выводить их.

***

### 3.3 Блочная структура программ

`От структур данных к структурам программ.`

Использование минимального набора инструкций позволяет решить проблему эффективной ***организации программ по управлению***.

Также важна проблема ***организации программ по данным***.

> - А как нам организовать всё?
> - Если не будет порядка программ по данным, то всё будет не очень эффективно.


Для этого в ранних языках — АЛГОЛ-60 — введена структура ***БЛОК***.
- `Блок` — фрагмент программы ***со своим локальным контекстом***.
- Блок определяется как `составная конструкция ЯП`, ограниченная скобками составного оператора / фигурными скобками на СИ.

> - Внутренние блоки возникают как борьба со сложностью.
> - Эти блоки разбивают большой на малые, в которых можно решить более мелкие задачи.

- Самый хороший пример локального контекста — `параметр цикла For`.
- Он отрабатывает столько, сколько ему написано.
- Эта временная переменная является параметром и сразу после завершения цикла становится ненужной.

Программы, процедуры и функции представляют собой блоки, т.к. имеют `описания локальных объектов`. 


С блоками можно не заботиться об уникальности имён при написании больших программ и защитить их от случайной порчи.

Локальные переменные облегчают работу в крупных программах.
Локализация позволяет сэкономить и разгрузить память.

Пока мы не вошли в блок, переменные не существуют, не объявлены.
Лишь при запуске программы компилятор их объявит.

У глобальных переменных всё объявлено.

>Каждый блок занимает свои локальные переменные только на время программы.
>Память большей части программы экономится, ибо почти весь блок и почти все переменные не задействованы.

> Если блок вложен, то основной блок "видит" и может пользоваться вложенными переменными, но своими внутренними переменными он не разрешает пользоваться.

Если программа примитивна (в ней мало букв), то одноимённые (омонимичные) переменные ***экранируются***!

> Приоритет отдаётся локальным переменным над глобальными при конфликте имён.

![image](https://user-images.githubusercontent.com/113284506/211193295-3f4db77f-2c9c-4ff4-a2ee-639f9e34e82b.png)

![image](https://user-images.githubusercontent.com/113284506/211193298-dc3b1294-b3d7-4805-9b41-e9ccb1facaec.png)

![image](https://user-images.githubusercontent.com/113284506/211193305-9ad5bcfc-39a1-46df-a6bd-56b14602b7a3.png)


> © Pascal не позволяет демонстрировать программирование на первом семестре нормального курса! (нет блоков)

- Любые переменные в языке СИ `по умолчанию` имеют `класс памяти auto` (есть ещё класс static).



***Пример с присваиванием***:

x1*y := y1*x — пример на дейкстровском питоне

Дейкстра-питон хорош тем, что в нём нет загромождения программы лишними переменными.

Пример на ЯП с обычным присваиванием:

```
t:=x
x:=y
y:=t
```

t нужен здесь только в конце!
Это переменная для swapping'а значений.


- Чтобы изучить рекурсию, надо изучить блочную структуру.

> - Текст в ТеХ описан как блочная структура.
> - Вообще структура и иерархия программ заимствована у естественных текстов.

```yaml
© Pascal очень удобно ругать..
- Мальчик для битья..
```

***

## 3.4. Процедуры и функции

Функции и процедуры, как и блоки, — представляют программу в виде четкой структуры из логически связанных подпрограмм.
Позволяют превратить повторяющиеся фрагменты программы в процедуры и избежать лишних ошибок.

Фактически каждый набор функций — интерпретативное расширение ЯП.
- Они позволяют построить `абстрактные` типы данных — не имеющие прямой программной поддержки.

- `Процедуры` более сложны, чем блоки, т.к. постоянно, `динамически параметризируются` (т.е. в процессе выполнения, а не компиляции).

Это более развитые программные единицы относительно блоков.


***

## 3.4.1. Описание и использование

- `Подпрограмма` — именованный фрагмент программы, предназначенный для выполнения специальной инструкцией обращения.

Подпрограмма принадлежит инструкции вызова благодаря имени и набору значений `фактических параметров` для вычислений

Подпрограмму надо описать перед использованием.
Она состоит из 2 частей: заголовка и тела.
В заголовке помимо имени пишется вид подпрограммы, параметры.

Параметры перечислены списком, по порядку следования — **позиционно**.

Тело представляет собой блок и содержит описания локальных и глобальных объектов вместе с совокупностью инструкций алгоритма.

***

## 3.4.2 Вызов функций и процедур.

- `Формальные параметры` — параметры заголовка (dummy, пустышки).
Этим достигается универсальность программ в сравнении с блоками.
- Формальным параметрам (локальным переменным) не отводится памяти при трансляции — они лишь обозначают объекты подпрограммы. 

- Подпрограммы-функции отличаются от процедур явно присвоенным имени результатом (как правило скалярным).

Функции нужен результат, чтобы дальше участвовать в программе.

Результат подпрограммы остаётся на регистре (в регистровом файле).
В языке СИ структурированные подпрограммы.

Приквел хорошего тона: функция не должна менять свои аргументы.
	
***

## 3.4.3 Передача параметров (кратко описываем каждый)

С её помощью связывают подпрограмму и внешнюю среду, из которой к подпрограмме обращаются.

***

## 3.4.3.1 Передача по значению

```
© Мы не машина Тьюринга, чтобы всё копировать.
```

- `Локальной переменной` при вызове подпрограммы выделяется память (в области данных программы) в соответствии с типом.

Значение локальной переменной вычисляется в точке вызова подпрограммы и отсылается в память, и связь прекращается.

В Паскале передаём по значению ***неуказанием*** `var` у переменной.

***

## 3.4.3.2 Передача по результату

- `Локальной переменной` при вызове подпрограммы выделяется память (в области данных программы) в соответствии с типом и присваивается начальное значение.

При завершении подпрограммы по адресу возвращается вычисленное значение результата — указание `result` или `out`.

Передача выражений и констант по результату бессмысленна и может быть синтаксически некорректной в строго типизированном языке.

Передача массивов по значению или результату помимо удвоенного расхода памяти на формальные параметры требует копирования содержимого массива
+сложностные оценки, оценки памяти.

***

## 3.4.3.3 Передача по ссылке

- При передаче по ссылке подпрограмме передаётся не значение, а адрес объектов.
- Обращения происходят по этому адресу.
- Объект без копирования играет роль временного параметра — не производится передача самого значения и возврат результата.

***Плюсы***: выигрыш по времени (значения не копируются) и по памяти (работа с оригинальным значением).

При этой передачи не стоит задавать константы — они могут быть испорчены.

***

## 3.4.3.4 Передача по имени

Обработка `локальных переменных` откладывается до их использования.
- Это самый мощный способ передачи, при этом самый опасный и неэффективный. Его ввели в Алголе-60.

Перед выполнением подпрограммы значение `фактического параметра` текстуально без предварительных вычислений
подставляется вместо `формального параметра`.

- Вместо передачи значения или ссылки в тело программы подаётся правило вычисления параметра.
- Значение параметра вычисляется при каждом обращении к подпрограмме заново.
- Вычисляются в контексте вызова, а не в контексте буквальной подстановки.

![image](https://user-images.githubusercontent.com/113284506/211189933-75b48a24-3fcd-4cb9-958c-60a10c0d9dfb.png)

***

## Выводы о передаче параметров

- `Значение программы` — её ***двоичное выполнимое тело***, субъект, а не объект обработки данных.
- Поэтому передача ***по значению-результату*** не имеет особого смысла.
- Передача ***по ссылке*** отражает парадигму передачи управления по заданному адресу в машине фон Неймана.

***Критерии выбора способа передачи:***

- Защита области данных от влияния подпрограммы
- Защита данных от изменения до завершения подпрограммы
- Экономия памяти
- Экономия времени вычислений
- Простота реализации


