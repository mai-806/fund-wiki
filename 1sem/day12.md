# 12 День. Файлы, блоки

- [d10. Нотация Дейкстры](https://mai-806.github.io/fund-wiki/1sem/day10.html) <--> [d11. Типы данных](https://mai-806.github.io/fund-wiki/1sem/day11.html) <--> [d12. Файлы, блоки](https://mai-806.github.io/fund-wiki/1sem/day12.html) <--> [d13. Критика фон Неймана, рекурсия](https://mai-806.github.io/fund-wiki/1sem/day13.html)

- [d1. Раскладки клавиатур, кодировки](https://mai-806.github.io/fund-wiki/1sem/day1.html) <--> [d6. Системы программирования](https://mai-806.github.io/fund-wiki/1sem/day6_2.html) <--> [d9. Железки (1-12)](https://mai-806.github.io/fund-wiki/1sem/day9.html) <--> [d14. Железки (13-35)](https://mai-806.github.io/fund-wiki/1sem/day14.html) <--> [d15. Железки (36-74)](https://mai-806.github.io/fund-wiki/1sem/day15.html) 

***

## Словарик программиста (надо знать!):

- `Запись` — комбинированный ***структурный тип*** с квалифицированным доступом.
- `Подпрограмма` — именованный фрагмент программы, предназначенный для выполнения специальной инструкцией обращения.
- `Структура файла` — обобщение понятия последовательности.
- `Файл` — это НЕ МАССИВ НА ДИСКЕ! Это ошибка!
- `Перемотки` — один из методов обработки **длинных последовательностей** (файлов, иначе говоря).

***

```yaml
© Снег выпал...
- Уже погуляли, надо возвращаться!
```

***

### 3.2.10 Понятие о записях

- [Можно почитать здесь](https://studfile.net/preview/2238048/page:25/#53)

- `Запись` — комбинированный ***структурный тип*** с квалифицированным доступом.
- `Комбинированный` — значит, что поля записи имеют различные типы.

Квалифицированный доступ, в отличие от индексированного, негибок и невычислим, т.к. требует явного указания
статически определённых до компиляции имён полей, но это компенсируется большой семантической нагрузкой этих имён. 

Здесь мы должны работать каждым компонентом записи вручную.

> © Нельзя решить проблему за раз, спустив курок.
> - С ней надо разделываться постепенно.

Нельзя сказать, что запись — долгий процесс, просто он не автоматический.
Это компенсируется большой семантической нагрузкой: программист не забудет, что он написал.

> - Записи неудобны для регулярной обработки, но они несут в себе смысл, и ты не перепутаешь переменные даже через неделю.
> - Мнемоника нужна сегодня, чтобы не ошибиться, и завтра, чтобы не забыть, что вы написали.

Дата рождения — субструктура, поля которой более очерчены.

![image](https://user-images.githubusercontent.com/113284506/211161850-ce1881a8-ed48-4135-a255-6e2aa649df90.png)

![image](https://user-images.githubusercontent.com/113284506/211161859-711d6e23-4d3a-45cf-9a16-180ddf4765bd.png)

![image](https://user-images.githubusercontent.com/113284506/211161868-b1b81e1c-0e0d-4052-8299-cec695a29e15.png)

![image](https://user-images.githubusercontent.com/113284506/211161875-360fe896-2c91-4a35-8638-229ae22a0597.png)


Вариантные записи позволяют обойти типовую безопасность.
На примере девятки рассмотрим разные типы данных:
- True — булевский
- 9 — 9 (Char)
- 9 — 57 (Код ASCII) (И какой это тип?)
- 9 — 0,00000+e00 (Вещественный)

У каждого из этих типов своя алгебра, свои отношения и значения.

Булевский: все нули (False), хотя бы одна единица (True).
А по целому? Определяем, дополнительный ли этот код (по первому числу)

Как видим, 4 типа совершенно разной интерпретации.

***

### 3.2.11 Понятие о файлах

```yaml
- У нас негласный запрет
- на обработку файлов через массивы
```

> © Самый маленький файл всегда больше самого большого массива.

***Файл*** — обобщённая последовательность (из математики). `Структура файла` — обобщение понятия последовательности.

> - Массив — доступен за постоянное время
> - Файл — доступен за линейное время
> - Размеры файлов велики, но при этом конечны.
> - И файлы надо постепенно прочитывать.

Обращение к диску содержит 2 действия за линейное время и одно движение за постоянное время.

> - Торможение, движение назад всегда медленнее движения вперёд, потому что назад двигаться нельзя (инерционные законы Ньютона, правила электро-механики).

`Считаем, что файл — мгновенная лента.`

> В методичке сказано, что "файл — массив на диске".
> - `Это ошибка, ловушка для шпиона!`
> - Не следует загонять файлы в массивы!

`Допущение таких ошибок показывает безграмотность.`

Держать в памяти разрешено одну или несколько компонент файла. Запрещено помещать в память любую долю от бесконечно большого файла.
Также мы не храним строки текстового файла, т.к. длина не ограничена.

Файлы принято подразделять на: внешние и внутренние, текстовые и нетекстовые, входные и выходные.

***

### Внешние файлы

`Внешние файлы` перечисляются в заголовке программы.
Они существуют до начала работы и сохраняются после окончания работы программы.
Т.е. время жизни именованных файлов ***шире*** времени жизни ***программы***.

- Программа стирается сразу ***после использования***, но не файл.

Именование файла должно сопоставляться и с Unix, и с языком СИ!
Это важно!

> - Кто сопоставит имя файла на pascal с Unix?
> - Обычно это делает **динамическое сопоставление**, в момент ***runtime***.
> - Не компилятор!
> - Это делает `языковая среда` во время `runtime`!
> - Файлы медленны в доступе и в работе, зато они долговременны, и хранить их в оперативной памяти дороже.
> - Сам прикинь стоимость жёсткого диска и оперативной памяти.
> - К тому же, оперативной памяти всё время нужно электричество, чтобы в ней что-то хранилось, а файл может годами лежать на жёстком диске.

***

### Внутренние файлы

`Внутренние файлы` описываются, как и внешние, как файловые переменные в программе. 
Они используются в качестве рабочих файлов — временной памяти почти неограниченного размера.

***

### Текстовые файлы

`Текстовые файлы` — файлы из литер, универсальный тип для ввода-вывода данных или для их хранения в предназначенном для этого виде.

Файлы сами по себе полезны: у них есть строки, причём строки переменной длины.

В файлах имеются символы EOL, которые разбивают структуру на строки.

> - Не все догадываются, что длина строки может быть нулевой.
> - А это одна из тонкостей!

***

### Нетекстовые файлы

`Нетекстовые файлы` хранят данные во внутреннем представлении и не предназначены для ввода-вывода.
Это компактно и экономит внешнюю память и время передачи данных в основную память.

> - Т.е. не как код ASCII, а как код в машинном виде.

Причем экономия достигается также и потому, что не требуется перевода значений в текстовые изображения и обратно, как это делается при вводе ***real*** и ***integer*** из/в файлы ***Input***/***Output***.


Пример — данные, снятые с датчиков.
- Они не предназначены для прямого восприятия человеком. Они не для человеческого уха или зрения.
- Они предназначены для плеера, или для устройства воспроизведения.

> - И правда, двоичный машинный код мы можем понять лишь через представление в устройстве, аппаратную реализацию. 

При вводе-вывод сканируем код по схеме Горнера за линейное время, и при этом экономим время, но усложняется сам процесс компиляции.

***

### 3.3 Блочная структура программ

Использование минимального набора инструкций позволяет решить проблему эффективной ***организации программ по управлению***.

Также важна проблема ***организации программ по данным***.

> - А как нам организовать всё?
> - Если не будет порядка программ по данным, то всё будет не очень эффективно.


Для этого в ранних языках — АЛГОЛ-60 — введена структура ***БЛОК***.

`Блок` — фрагмент программы ***со своим локальным контекстом***. Он определяется как `составная конструкция ЯП`, ограниченная скобками составного оператора / фигурными скобками на СИ.

> - Внутренние блоки возникают как борьба со сложностью.
> - Эти блоки разбивают большой на малые, в которых можно решить более мелкие задачи.

Типичный пример локального контекста — `параметр цикла For`. Эта временная переменная сразу после завершения цикла становится ненужной.

Программы, процедуры и функции представляют собой блоки, т.к. имеют `описания локальных объектов`. 

Блоки позволяют не заботиться об уникальности имён при написании больших программ и защищают их от случайной порчи.

Локальные переменные облегчают работу в крупных программах.
Локализация позволяет сэкономить и разгрузить память.

Пока мы не вошли в блок, переменные не существуют, не объявлены.
Лишь при запуске программы компилятор их объявит.

У глобальных переменных всё объявлено.

> - Каждый блок занимает свои локальные переменные только на время программы.
> - Память большей части программы экономится, ибо почти весь блок и почти все переменные не задействованы.

> - Если блок вложен, то основной блок "видит" и может пользоваться вложенными переменными, но своими внутренними переменными он не разрешает пользоваться.

Если программа примитивна (в ней мало букв), то одноимённые (омонимичные) переменные ***экранируются***!

> Приоритет отдаётся локальным переменным над глобальными при конфликте имён.

![image](https://user-images.githubusercontent.com/113284506/211193295-3f4db77f-2c9c-4ff4-a2ee-639f9e34e82b.png)

![image](https://user-images.githubusercontent.com/113284506/211193298-dc3b1294-b3d7-4805-9b41-e9ccb1facaec.png)

![image](https://user-images.githubusercontent.com/113284506/211193305-9ad5bcfc-39a1-46df-a6bd-56b14602b7a3.png)


> © Pascal не позволяет демонстрировать программирование на первом семестре нормального курса! (нет блоков)

- Любые переменные в языке СИ `по умолчанию` имеют `класс памяти auto` (есть ещё класс static).



***Пример с присваиванием***:

x1*y := y1*x — пример на дейкстровском питоне

Дейкстра-питон хорош тем, что в нём нет загромождения программы лишними переменными.

Пример на ЯП с обычным присваиванием:

```
t:=x
x:=y
y:=t
```

t нужен здесь только в конце!
Это переменная для swapping'а значений.


- Чтобы изучить рекурсию, надо изучить блочную структуру.

> - Текст в ТеХ описан как блочная структура.
> - Вообще структура и иерархия программ заимствована у естественных текстов.

```yaml
© Pascal очень удобно ругать..
- Мальчик для битья..
```

***

## 3.4. Процедуры и функции

Функции и процедуры, как и блоки, представляют программу в виде четкой структуры из логически связанных подпрограмм.
Позволяют превратить повторяющиеся фрагменты программы в процедуры и избежать лишних ошибок.

Фактически каждый набор функций — интерпретативное расширение ЯП.
- Они позволяют построить `абстрактные` типы данных, не имеющие прямой программной поддержки.

`Процедуры` более сложны, чем блоки, т.к. постоянно, `динамически параметризируются` (т.е. в процессе выполнения, а не компиляции).

Это более развитые программные единицы относительно блоков.

***

## 3.4.1. Описание и использование

- `Подпрограмма` — именованный фрагмент программы, предназначенный для выполнения специальной инструкцией обращения.

Подпрограмма принадлежит инструкции вызова благодаря имени и набору значений `фактических параметров` для вычислений

Подпрограмму надо описать перед использованием.
Она состоит из 2 частей: заголовка и тела.
В заголовке помимо имени пишется вид подпрограммы, параметры.

Параметры перечислены списком, по порядку следования — **позиционно**.

Тело представляет собой блок и содержит описания локальных и глобальных объектов вместе с совокупностью инструкций алгоритма.

![image](https://user-images.githubusercontent.com/113284506/217348190-9868e12d-713b-459d-bad0-3f361167d1ab.png)

![image](https://user-images.githubusercontent.com/113284506/217348222-42fe5d79-629d-4e86-a7c4-1d4bb44a20f1.png)

***

## 3.4.2 Вызов функций и процедур.

- `Формальные параметры` — параметры заголовка (dummy, пустышки).
Этим достигается универсальность программ в сравнении с блоками.
- Формальным параметрам не отводится памяти при трансляции — они лишь обозначают объекты подпрограммы. 

- Подпрограммы-функции отличаются от процедур явно присвоенным имени результатом (как правило скалярным).

Функции нужен результат, чтобы дальше участвовать в программе.

Результат подпрограммы остаётся на регистре (в регистровом файле).
В языке СИ структурированные подпрограммы.

> - Приквел хорошего тона: функция не должна менять свои аргументы.
	
***

## 3.4.3 Передача параметров (кратко описываем каждый)

С её помощью связывают подпрограмму и внешнюю среду, из которой к подпрограмме обращаются.

***

## 3.4.3.1 Передача по значению

```
© Мы не машина Тьюринга, чтобы всё копировать.
```

- `Формальному параметру` при вызове подпрограммы выделяется память (в области данных программы) в соответствии с типом.

Значение каждого фактического параметра вычисляется в точке вызова подпрограммы и отсылается в память, после чего связь прекращается.

В Паскале передаём по значению ***неуказанием*** `var` у переменной.

![image](https://user-images.githubusercontent.com/113284506/217349620-da9c7d84-cf73-47b4-b667-88809b8e6bb3.png)


***

## 3.4.3.2 Передача по результату

- `Формальному параметру` при вызове подпрограммы выделяется память (в области данных программы) в соответствии с типом и присваивается начальное значение.

При завершении подпрограммы по адресу возвращается вычисленное значение результата — указание `result` или `out`.

![image](https://user-images.githubusercontent.com/113284506/217349485-8f1813e6-ccea-4a22-bdfb-b681d4782a74.png)

Передача выражений и констант по результату бессмысленна и может быть синтаксически некорректной в строго типизированном языке.

Передача массивов по значению или результату помимо удвоенного расхода памяти на формальные параметры требует копирования содержимого массива
+ сложностные оценки, оценки памяти.

***

## 3.4.3.3 Передача по ссылке

- При передаче по ссылке подпрограмме передаётся не значение, а адрес объектов.
- Обращения происходят по этому адресу.
- Объект без копирования играет роль временного параметра — не производится передача самого значения и возврат результата.

***Плюсы***: выигрыш по времени (значения не копируются) и по памяти (работа с оригинальным значением).

При этой передачи не стоит задавать константы — они могут быть испорчены.

***

## 3.4.3.4 Передача по имени

Обработка `фактических параметров` откладывается до их использования.
- Это самый мощный способ передачи, при этом самый опасный и неэффективный. Его ввели в Алголе-60.

Перед выполнением подпрограммы значение `фактического параметра` текстуально без предварительных вычислений
подставляется вместо `формального параметра`.

- Вместо передачи значения или ссылки в тело программы подаётся правило вычисления параметра.
- Значение параметра вычисляется при каждом обращении к подпрограмме заново, причем в контексте вызова, а не в контексте буквальной подстановки.

![image](https://user-images.githubusercontent.com/113284506/211189933-75b48a24-3fcd-4cb9-958c-60a10c0d9dfb.png)

***

## Выводы о передаче параметров

- `Значение программы` — её ***двоичное выполнимое тело***, субъект, а не объект обработки данных.
- Поэтому передача ***по значению-результату*** не имеет особого смысла.
- Передача ***по ссылке*** отражает парадигму передачи управления по заданному адресу в машине фон Неймана.

***Критерии выбора способа передачи:***

- Защита области данных от влияния подпрограммы
- Защита данных от изменения до завершения подпрограммы
- Экономия памяти
- Экономия времени вычислений
- Простота реализации

***

- [d10. Нотация Дейкстры](https://mai-806.github.io/fund-wiki/1sem/day10.html) <--> [d11. Типы данных](https://mai-806.github.io/fund-wiki/1sem/day11.html) <--> [d12. Файлы, блоки](https://mai-806.github.io/fund-wiki/1sem/day12.html) <--> [d13. Критика фон Неймана, рекурсия](https://mai-806.github.io/fund-wiki/1sem/day13.html)

- [d1. Раскладки клавиатур, кодировки](https://mai-806.github.io/fund-wiki/1sem/day1.html) <--> [d6. Системы программирования](https://mai-806.github.io/fund-wiki/1sem/day6_2.html) <--> [d9. Железки (1-12)](https://mai-806.github.io/fund-wiki/1sem/day9.html) <--> [d14. Железки (13-35)](https://mai-806.github.io/fund-wiki/1sem/day14.html) <--> [d15. Железки (36-74)](https://mai-806.github.io/fund-wiki/1sem/day15.html) 
