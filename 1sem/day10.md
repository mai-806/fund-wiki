# 10 день. Элементы дейкстровской нотации

- [d10. Нотация Дейкстры](https://mai-806.github.io/fund-wiki/1sem/day10.html) <--> [d11. Типы данных](https://mai-806.github.io/fund-wiki/1sem/day11.html) <--> [d12. Файлы, блоки](https://mai-806.github.io/fund-wiki/1sem/day12.html) <--> [d13. Критика фон Неймана, рекурсия](https://mai-806.github.io/fund-wiki/1sem/day13.html)

- [d1. Раскладки клавиатур, кодировки](https://mai-806.github.io/fund-wiki/1sem/day1.html) <--> [d6. Системы программирования](https://mai-806.github.io/fund-wiki/1sem/day6_2.html) <--> [d9. Железки (1-12)](https://mai-806.github.io/fund-wiki/1sem/day9.html) <--> [d14. Железки (13-35)](https://mai-806.github.io/fund-wiki/1sem/day14.html) <--> [d15. Железки (36-74)](https://mai-806.github.io/fund-wiki/1sem/day15.html) 

***

## Словарик программиста:

- `Принстон` — программы и данные ***на одном устройстве памяти***. Небезопасно.
- `Гарвард` — ***раздельная реализации*** памяти для программ и для данных, что безопаснее.
- `Программа` — текст, включающий в себя инструкции описания объектов, ввода, обработки, вывода данных.
- `Недетерминированность ветвления` — выбор истинного ветвления не определяется порядком записи.
- `Ветвление` — разбиение на альтернативные ветки.
- `Альтернативные` — когда другие ветки не рассматриваются в случае успеха одной.
- `Массив` — структурный тип данных, совокупность компонентов одного и того же ***скалярного типа***.
- Компоненты массива обозначены явно и доступны по `индексам`.
- `Индекс` — функция, которая по значениям количества компонентов определяет их адрес. 

***

```yaml
© У нас форма распространения знаний устная!
```

# Глава 3. Элементы дейкстровской нотации

## 3.1.1 Требования к структуре программ для машины фон Неймана

Машина фон Неймана состоит из управляющего устройства, памяти и регистров.

Для работы в её памяти должны быть объекты: 
- программа
- таблица имён
- все данные, которые надо обработать

Объекты связаны с адресами памяти специальными ячейками.

Правильность работы программы зависит от программиста, поскольку память — хранилище слов без какой-либо интерпретации.


- `Принстонская архитектура` названа в честь института, в котором преподавал фон Нейман. Она отличается совместным размещением программы и данных в памяти, лишь на регистре процессора их можно различить. Такая реализация хорошо своей скоростью выполнения сгенерированной в памяти программы, но её недостаток — уязвимость к вирусам.

- `Гарвардская архитектура` основана на раздельной реализации памяти для программ и для данных, что безопаснее (ценой аппаратурных затрат).

Составление таблицы имён можно автоматизировать правками текста программы,
а для полной автоматизации процесса надо указать тип процессора обработки данных.

Для упрощения помещаем таблицу имён в начало программы.

Для обработки объект должен иметь значение, отличное от `боттом` `_|_` (знак неопределённости — перевёрнутая Т).

- Паскаль и Си требуют обязательного описания всех объектов, кроме предопределённых.

```
int i, j, k;
```

Данные в памяти недоступны для восприятия человеком, т.е. представлены `внутренне`.
Их надо преобразовать во `внешнее` представление на доступном человеку носителе — произвести `вывод данных`.

Инструкции ввода и вывода могут находиться в любом месте программы.
При этом важно, чтобы результат обработки данных предшествовал их выводу.


- `Программа` машины фон Неймана — текст, включающий в себя инструкции описания объектов, ввода, обработки, вывода данных. 

***

## 3.1.2 Обобщённая инструкция присваивания

Машина обрабатывает данные `покомандно`. 
Операнды вызываются на регистры из памяти, и команда выполняет действия над ними, оставляя результат на регистрах.

Основная инструкция обработки данных любого ЯП — инструкция присваивания. 

```
x = a
```

- `x` — имя объекта, `a` — действие над операндами, `=` — знак присваивания.

Всё, что в ***левой границе*** присваивания — `lvalue`.

Значение переменной копируется на свободный регистр, а с регистра — в ячейку памяти, сопоставленную с `lvalue`.
На практике проверка на неопределённость значения переменно не выполняется — это замедляет исполнение программы.

Операнды в выражении выражаются словами одного типа, иначе — согласуются, что происходит перед отправкой копии в ячейку `lvalue`. 

Обобщение инструкции присваивания задаёт ***одновременную замену значений*** нескольких объектов.

Левая часть присваивания будет списком объектов, а правая — выражения, соответствующие левым объектам.

- Одновременное присваивание аналогично обычному.

![image](https://user-images.githubusercontent.com/113284506/211200216-0657cd86-af9a-4949-9237-9c2589b8a22c.png)

На Pascal символ присваивания ***составной***: `:=`, а в Си — ***атомарный*** `=`


На языке СИ нельзя присваивать массивы или структуры!
Есть лишь константный указатель на память, который должен быть в левой части присваивания.

А также в Си есть условное присваивание, в Pascal его нет:

![image](https://user-images.githubusercontent.com/113284506/211200531-9ac744a9-dc68-47ec-b245-ae88a7e961ac.png)


***

## 3.1.3 Обобщенная инструкция композиции

- `Композиция` — составная инструкция, при которой значения одной функции используются как аргументы для другой.

Для минимизации вычислений процесс разбивают на ряд последовательных подвыражений, разделённых точкой с запятой. 
В Си композиция инструкций скрепляется знаками `{ }`

![image](https://user-images.githubusercontent.com/113284506/217335402-6082daf5-f20d-48e9-a031-83da5cc0a811.png)

![image](https://user-images.githubusercontent.com/113284506/217335436-e5ed12a8-ae25-481e-9f56-2f349f02a559.png)



![image](https://user-images.githubusercontent.com/113284506/211202116-7d998f78-52a2-4178-995b-b5f2917dccd8.png)


При параллельной композиции знаком разделения ветвей будет `||`. 

***

## 3.1.4 Охраняемые инструкции

`Охраняемую инструкцию` используют для возможности разрешать/запрещать выполнение инструкции в зависимости от выполнения условий.  

Она снабжена `предохранителем`.

![image](https://user-images.githubusercontent.com/113284506/211202292-922f704e-eac0-43ba-8973-24896e99f05a.png)

![image](https://user-images.githubusercontent.com/113284506/211202314-82acf9c4-1e81-4faf-8bea-e074a84a828d.png)

Предохранитель используют в ветвлении и цикле.

> Это обычно называют `тернарным оператором`

[Подробнее почитать здесь](https://narodstream.ru/c-urok-11-ternarnyj-operator/)

***

## 3.1.5 Обобщённое ветвление

![image](https://user-images.githubusercontent.com/113284506/217336017-d30ccd2a-bd8e-4bf2-8b0e-79fdd05f8f4a.png)


***Правила выполнения ветвления (инструкции IF-FI)***:

1) Предохранители и предикаты одновременно и независимо вычисляются.

2) Чтобы ветвление разветвилось, должна быть хотя бы одна истинная ветка, иначе ***аварийный отказ***. Ошибка при планировании ветвления лежит на плечах программиста.

3) Допустимо наличие более чем 1 истинного предиката.


Выбор истинного ветвления не определяется порядком записи — предохранители не упорядочены.
Это называют `недетерминированностью ветвления`. 
- ***Но это не является случайностью!*** Случайность подчинена законам вероятности, что противоречит недетерминированности. 

У них свои наборы регистров и переменных, не влияющие друг на друга.

Но компилятор вряд ли может обнаружить ошибку, поскольку она проявляется лишь в процессе runtime.

```yaml
© Клянусь мамой, программа работает!
- Ставлю печать!
```


> - Программист должен страдать над ветками ветвления.
> - Составляя их, он должен думать, чтобы ветвление анализировало предикаты.


- `Ветвление` — разбиение на альтернативные ветки.
- `Альтернативные` — когда другие ветки не рассматриваются в случае успеха одной.


Выбрать и выполнить ветку — одно из основных назначений ветвления.

```
Если отдых, то отправляемся в Сочи.
- Если неважно,
- самолётом или на поезде,
- тогда проявляется 
- недетерминированнось.
```

> При неалгоритмическом ветвлении ветка выбирается не случайно!
> - И не по весу, не по цене!
> - Случайная ветка не является детерминированной.
> - Недетерминированное программирование облегчает выполнение задач.


Ветвление на 2 ветки выполняется одним предикатом и никогда не отказывает (***двузвенное ветвление***).
Ветвление выбирает одну из двух альтернативных ветвей.


```
© Язык СИ — это птичий,
- более лаконичный язык.
- В нём больше скобочек, значков.
```

****

***Что в нём плохого:*** 

- break — показатель американского грубого языка!
- в СИ нет встроенного стека!

> © Нужны бойцовские качества! Надо уметь ругать языки — тогда вы выплывете на любом собеседовании!

> - Когда попадает к вам язык, необходимо узнать его ***с точки зрения Дейкстры*** (ветвлений), что в нём роскошного.

***

## 3.1.6 Обобщённая инструкция цикла

- `Цикл` — средство организации многократного выполнения вычислений до момента превышения заданного значения.

- Цикл содержит условие завершения в форме предиката.

![image](https://user-images.githubusercontent.com/113284506/217336179-f5ff59ae-f297-42b4-b806-1403591bdf40.png)


***Правила выполнения цикла:***

1) Ветка выполняется, если предохранитель `истинный`. 

2) Количество истинных предохранителей может быть более 1.

3) При отсутствии истинных веток `цикл может не работать`.

4) Выполнение каждой охраняемой инструкции приводит к изменению аргументов.

- Ветки при выполнении влияют на переменные и немного на предикаты.
- Цикл работает до последнего предиката и имеет внутри будто бы обобщённое ветвление.
- Обобщённый цикл работает до последнего предиката!
- Цикл работает много раз, пока одна ветка выполняется.

> Предохранитель в IF FI обеспечивает более защитное программирование, отказ обнаруживается раньше.


> - Цикл с предусловием может не работать.

> - do while — постусловие
> - while do — предусловие

> Pascal — untill not (двойное отрицание, использовалось, чтобы формулировка цикла была точной.
> При отрицании условия — просто Untill, при согласии — двойное отрицание).

***

# 3.2 Типы данных

## 3.2.1 Определение типа данных


Данные — сообщения в машинно-читаемом операбельном виде.

- `Тип данных` — множество слов алфавита ***с правилом интерпретации*** для ***сопоставления*** значений слов с `атрибутами` другого или того же типа.  

- `Атрибуты данных` — отношения и функции над значениями этого типа. 

***Атрибуты данных***:

- операции
- функции
- отношения
- константы


## Эффективные способы задания типов:

1) Перечислением множества изображений. Сводятся к начальному отрезку натурального ряда. 
- Перечислимый тип "паразитирует" на целом типе и его реализация нецелесообразна. 

![image](https://user-images.githubusercontent.com/113284506/211205705-b029d89a-3665-4d41-9ba0-774a148737d1.png)

2) Заданием характеристической функции (предиката), истинного, когда изображение относится к данному типу.
- Этот тип тоже не может быть первичным, т.к. базируется на некотором надмножестве изображений.

3) С помощью системы аксиом, содержащих свойства изображений. 
- Способ математически красив, но неконструктивен, т.к. не позволяет порождать значения в явном виде.

***

***Первая отечественная ЭВМ БЭСМ.***

Она также представляла собой МТ и была неудобной:
на ней также приходилось моделировать числа вещественного типа.

- Первый компьютер — американский!
- Второй — британский!
- Но первый континентальный — отечественный!

> Всего было ***4 пришествия МТ***:
> - Первой МТ была она сама;
> - Второй МТ — первые компьютеры;
> - Третья МТ — бортовые компьютеры;
> - Четвёртая МТ — первое появление микроархитектуры.

> И всё это делали ***умные люди***, с математическим подходом!
> - Они знали матанализ!

***

![image](https://user-images.githubusercontent.com/113284506/211206130-a8dbf04a-be6f-4cf7-b11d-e2359e63a5df.png)

![image](https://user-images.githubusercontent.com/113284506/211206168-4348b3eb-da98-458e-a851-07aec969e034.png)


`Перечислимый тип` основан на задании слов, пронумерованных в порядке описания и несущих смысловую нагрузку.

Соответствующий тип может быть задан ***отрезком***, или `диапазоном`.

![image](https://user-images.githubusercontent.com/113284506/211206668-ae268625-3327-4400-8d0b-48f4e7e87f53.png)

- `Массив` — структурный тип данных, совокупность компонентов одного и того же ***скалярного типа***.
Компоненты массива обозначены явно и доступны по `индексам`.

- `Индекс` — функция, которая по значениям количества компонентов определяет их адрес. 

***

## 3.2.2 Тип логический

![image](https://user-images.githubusercontent.com/113284506/211207165-f133ee4d-c376-4365-a678-5e1bbe509f24.png)


- bottom `_ | _`  это знак неопределённости. Он описывает класс ситуаций, когда результат не имеет осмысленной интерпретации.

![image](https://user-images.githubusercontent.com/113284506/211207191-d7bf5a03-d92c-4825-a597-c10c3185fe1e.png)


- На языках СУБД `_ | _` обозначается как NULL
- SQL читается как Сиквел.

> Если в машинном слове хотя бы одна единица, то истина.

![image](https://user-images.githubusercontent.com/113284506/211207250-2aaff3b7-f60a-49a0-8470-37bd7b9693e6.png)

![image](https://user-images.githubusercontent.com/113284506/217337418-d7aba329-4c7b-4256-b21e-6053367b2bb8.png)

![image](https://user-images.githubusercontent.com/113284506/211207107-a1bb3926-2545-4ee1-8012-0ec766b0009a.png)

***

## 3.2.3 Тип целый

Из курса алгебры знаем — это множество целых чисел вида 0-+1+-2, образующих `алгебраическое кольцо`
относительно сложения и умножения (деление разрывает кольцо — 7/2 не является целым числом). 

Эффективная вычислимость требует замены бесконечного числа чисел на конечный отрезок (множество), в который войдут числа между MIN MAX.

- Пример диапазона: [-32768; 32767].
- 0 входит в положительную часть, поэтому диапазон несимметричен.

- `Т` — переопределённое значение, депутат. Вместе с неопределённым значением `_ | _` они войдут в целый тип.

- Отношение в целом типе размыкает целый тип и переходит в булевский (введён в C99).
- Раз отношения размыкают логический тип, то они не являются операциями (3/5).

Отношения являются операциями если в результате получается тот же тип данных. А рациональные числа - размыкание целого типа.

![image](https://user-images.githubusercontent.com/113284506/211207650-419ad88d-7228-42c5-bdfd-133d3c3d6519.png)

![image](https://user-images.githubusercontent.com/113284506/211207535-d79f9f36-dcb8-4961-b999-34193e1a1d76.png)

![image](https://user-images.githubusercontent.com/113284506/211207545-3b070f37-403c-409e-bccb-e06209c90fbd.png)

***

> - Деление - медленная операция.

> - Алгоритм деления - не алгоритм. В нём есть элемент прикидки, эвристического подбора.
Деление сводится к вычитанию с эвристическим подбором.

***

- [d10. Нотация Дейкстры](https://mai-806.github.io/fund-wiki/1sem/day10.html) <--> [d11. Типы данных](https://mai-806.github.io/fund-wiki/1sem/day11.html) <--> [d12. Файлы, блоки](https://mai-806.github.io/fund-wiki/1sem/day12.html) <--> [d13. Критика фон Неймана, рекурсия](https://mai-806.github.io/fund-wiki/1sem/day13.html)

- [d1. Раскладки клавиатур, кодировки](https://mai-806.github.io/fund-wiki/1sem/day1.html) <--> [d6. Системы программирования](https://mai-806.github.io/fund-wiki/1sem/day6_2.html) <--> [d9. Железки (1-12)](https://mai-806.github.io/fund-wiki/1sem/day9.html) <--> [d14. Железки (13-35)](https://mai-806.github.io/fund-wiki/1sem/day14.html) <--> [d15. Железки (36-74)](https://mai-806.github.io/fund-wiki/1sem/day15.html) 
