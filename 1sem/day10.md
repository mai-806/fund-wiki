# 10 день. Элементы дейкстровской нотации

## Словарик программиста:

- `Принстон` — программы и данные ***на одном устройстве памяти***. Небезопасно.
- `Гарвард` — ***раздельная реализации*** памяти для программ и для данных, что безопаснее.
- `Программа` — текст, включающий в себя инструкции описания объектов, ввода, обработки, вывода данных.
- `Недетерминированность ветвления` — выбор истинного ветвления не определяется порядком записи.
- `Ветвление` — разбиение на альтернативные ветки.
- `Альтернативные` — когда другие ветки не рассматриваются в случае успеха одной.
- `Массив` — структурный тип данных, совокупность компонентов одного и того же ***скалярного типа***.
- Компоненты массива обозначены явно и доступны по `индексам`.
- `Индекс` — функция, которая по значениям количества компонентов определяет их адрес. 

***

```yaml
© У нас форма распространения знаний устная!
```

# Глава 3. Элементы дейкстровской нотации

## 3.1.1 Требования к структуре программ для машины фон Неймана

Машина фон Неймана состоит из управляющего устройства, памяти и регистров.
Для работы в её памяти должны быть объекты: 
- программа
- таблица имён
- все данные, которые надо обработать

Объекты связаны с адресами памяти — специальными ячейками.
- Правильность работы программы зависит от программиста — память есть хранилище слов без какой-либо интерпретации.

- `Программы и данные` помещены `на одном устройстве памяти`, лишь на регистре процессора команды и данные программы имеют различия.
Этот принцип назван `принстонской архитектурой`. Её недостаток в небезопасности.

- `Гарвардская архитектура` основана на раздельной реализации памяти для программ и для данных, что безопаснее (ценой аппаратурных затрат).


Составление таблицы имён можно автоматизировать правками текста программы,
а для полной автоматизации процесса надо указать тип процессора обработки данных.

Для упрощения помещаем таблицу имён в начало программы.

Для обработки объект должен иметь значение, отличное от `боттом` (знак неопределённости — перевёрнутая Т).

- Паскаль и Си требуют обязательного описания всех объектов, кроме предопределённых.

```
int i, j, k;
```

Данные в памяти недоступны для восприятия человеком, или представлены `внутренне`.
Их надо преобразовать во `внешнее` представление на доступном человеку носителе — произвести `вывод данных`.

Инструкции ввода и вывода могут находиться в любом месте программы.
При этом важно, чтобы результат обработки данных предшествовал их выводу.


- `Программа` машины фон Неймана — текст, включающий в себя инструкции описания объектов, ввода, обработки, вывода данных. 

***

## 3.1.2 Обобщённая инструкция присваивания

Машина осуществляет `покомандную` обработку данных. 
Операнды вызываются на регистры из памяти, и команда выполняет действия над ними, оставляя результат на регистрах (копируется в память).


Основная инструкция обработки данных любого ЯП — инструкция присваивания. 

```
x = a
```

- `x` — имя объекта, `a` — действие над операндами, `=` — знак присваивания.

Всё, что в ***левой границе*** присваивания — `lvalue`.

Значение переменной копируется на свободный регистр, а с регистра — в ячейку памяти, сопоставленную с `lvalue`.
На практике проверка на неопределённость значения переменно не выполняется — это замедляет исполнение программы.

Типы операндов в выражении должны выражаться словами одного типа, иначе — быть согласованными.
- Тогда согласование типов будет происходить перед отправкой копии в ячейку `lvalue`.

- `Обобщение инструкции присваивания` — задаёт ***одновременную замену значений*** нескольких объектов.
- Левая часть присваивания будет списком объектов, а правая — выражения, соответствующие левым объектам.

- Одновременное присваивание аналогично обычному.

![image](https://user-images.githubusercontent.com/113284506/211200216-0657cd86-af9a-4949-9237-9c2589b8a22c.png)

На Pascal символ присваивания ***составной***: `:=`, а в Си — ***атомарный*** `=`


На языке СИ нельзя присваивать массивы или структуры!
Есть лишь константный указатель на память, который должен быть в левой части присваивания.

А также в Си есть условное присваивание, в Pascal его нет:

![image](https://user-images.githubusercontent.com/113284506/211200531-9ac744a9-dc68-47ec-b245-ae88a7e961ac.png)

***

## 3.1.3 Обобщенная инструкция композиции

- `Композиция` — составная инструкция, при которой значения одной функции используются как аргументы для другой.

Для минимизации вычислений разбивают процесс на ряд последовательных подвыражений, разделённых точкой с запятой. 
В Си композиция инструкций скрепляется знаками `{ }`

![image](https://user-images.githubusercontent.com/113284506/211202116-7d998f78-52a2-4178-995b-b5f2917dccd8.png)


При параллельной композиции знаком разделения ветвей будет `||`. 

***

## 3.1.4 Охраняемые инструкции

`Охраняемую инструкцию` используют для возможности разрешать/запрещать выполнение инструкции в зависимости от выполнения условий.  

Она снабжена `предохранителем`.

![image](https://user-images.githubusercontent.com/113284506/211202292-922f704e-eac0-43ba-8973-24896e99f05a.png)

![image](https://user-images.githubusercontent.com/113284506/211202314-82acf9c4-1e81-4faf-8bea-e074a84a828d.png)

Предохранитель используют в ветвлении и цикле.

***

## 3.1.5 Обобщённое ветвление

***Правила выполнения ветвления (инструкции IF-FI)***:


1) Предохранители и предикаты одновременно и независимо вычисляются.

2) Чтобы ветвление разветвилось, должна быть хотя бы одна истинная ветка, иначе ***аварийный отказ***. Ошибка при планировании ветвления лежит на плечах программиста.

3) Допустимо наличие более чем 1 истинного предиката.


Выбор истинного ветвления не определяется порядком записи — предохранители не упорядочены.
Это называют `недетерминированностью ветвления`. 
- ***Но это не является случайностью!*** Случайность подчинена законам вероятности, что противоречит недетерминированности. 



У них свои наборы регистров и переменных, не влияющие друг на друга.

Но компилятор вряд ли может обнаружить ошибку, поскольку она проявляется лишь в процессе runtime.

```yaml
© Клянусь мамой, программа работает!
- Ставлю печать!
```


> - Программист должен страдать над ветками ветвления.
> - Составляя их, он должен думать, чтобы ветвление анализировало предикаты.


- `Ветвление` — разбиение на альтернативные ветки.
- `Альтернативные` — когда другие ветки не рассматриваются в случае успеха одной.


Выбрать и выполнить ветку — одно из основных назначений ветвления.

```
Если отдых, то отправляемся в Сочи.
- Если неважно,
- самолётом или на поезде,
- тогда проявляется 
- недетерминированнось.
```

> При неалгоритмическом ветвлении ветка выбирается не случайно!
> - И не по весу, не по цене!
> - Случайная ветка не является детерминированной.
> - Недетерминированное программирование облегчает выполнение задач.


Ветвление на 2 ветки выполняется одним предикатом и никогда не отказывает (***двузвенное ветвление***).
Ветвление выбирает одну из двух альтернативных ветвей.


```
© Язык СИ — это птичий,
- более лаконичный язык.
- В нём больше скобочек, значков.
```

****

***Что в нём плохого:*** 

- break — показатель американского грубого языка!
- в СИ нет встроенного стека!

> © Нужны бойцовские качества! Надо уметь ругать языки — тогда вы выплывете на любом собеседовании!

> - Когда попадает к вам язык, необходимо узнать его ***с точки зрения Дейкстры*** (ветвлений), что в нём роскошного.

***

## 3.1.6 Обобщённая инструкция цикла

- `Цикл` — средство организации многократного выполнения вычислений до момента превышения заданного значения.

- Цикл содержит условие завершения в форме предиката.

***Правила выполнения цикла:***

1) Ветка выполняется, если предохранитель `истинный`. 

2) Количество истинных предохранителей может быть более 1.

3) При отсутствии истинных веток `цикл может не работать`.

4) Выполнение каждой охраняемой инструкции приводит к изменению аргументов.

- Ветки при выполнении влияют на переменные и немного на предикаты.
- Цикл работает до последнего предиката и имеет внутри будто бы обобщённое ветвление.
- Обобщённый цикл работает до последнего предиката!
- Цикл работает много раз, пока одна ветка выполняется.

> Предохранитель в IF FI обеспечивает более защитное программирование, отказ обнаруживается раньше.


> - Цикл с предусловием может не работать.

> - do while — постусловие
> - while do — предусловие

> Pascal — untill not (двойное отрицание, использовалось, чтобы формулировка цикла была точной.
> При отрицании условия — просто Untill, при согласии — двойное отрицание).

***

# 3.2 Типы данных

## 3.2.1 Определение типа данных


Данные — сообщения в машинно-читаемом операбельном виде.

- `Тип данных` — `множество слов` алфавита ***с правилом интерпретации*** для ***сопоставления*** `значений` слов с `атрибутами` другого или того же типа.  

- `Атрибуты данных` — отношения и функции над значениями этого типа. 

***Атрибуты данных***:

- операции
- функции
- отношения
- константы


## Эффективные способы задания типов:

Например, с помощью таблицы, где представлены типы (или списка).

1) Перечислением множества изображений. Сводятся к начальному отрезку натурального ряда. 
- Перечислимый тип "паразитирует" на целом типе и его реализация нецелесообразна. 

![image](https://user-images.githubusercontent.com/113284506/211205705-b029d89a-3665-4d41-9ba0-774a148737d1.png)

2) Заданием характеристической функции (предиката), истинного, когда изображение относится к данному типу.
- Этот тип тоже не может быть первичным, т.к. базируется на некотором надмножестве изображений.

3) С помощью системы аксиом, содержащих свойства изображений. 
- Способ математически красив, но неконструктивен, т.к. не позволяет порождать значения в явном виде.

***

***Первая отечественная ЭВМ БЭСМ.***

Она также представляла собой МТ и была неудобной:
на ней также приходилось моделировать числа вещественного типа.

- Первый компьютер — американский!
- Второй — британский!
- Но первый континентальный — отечественный!

> Всего было ***4 пришествия МТ***:
> - Первой МТ была она сама;
> - Второй МТ — первые компьютеры;
> - Третья МТ — бортовые компьютеры;
> - Четвёртая МТ — первое появление микроархитектуры.

> И всё это делали ***умные люди***, с математическим подходом!
> - Они знали матанализ!

***

![image](https://user-images.githubusercontent.com/113284506/211206130-a8dbf04a-be6f-4cf7-b11d-e2359e63a5df.png)

![image](https://user-images.githubusercontent.com/113284506/211206168-4348b3eb-da98-458e-a851-07aec969e034.png)


- `Перечислимый тип` основан на задании слов, пронумерованных в порядке описания и несущих смысловую нагрузку.
- Соответствующий тип может быть задан ***отрезком***, или `диапазоном`.

![image](https://user-images.githubusercontent.com/113284506/211206668-ae268625-3327-4400-8d0b-48f4e7e87f53.png)

- `Массив` — структурный тип данных, совокупность компонентов одного и того же ***скалярного типа***.
- Компоненты массива обозначены явно и доступны по `индексам`.
- `Индекс` — функция, которая по значениям количества компонентов определяет их адрес. 

***

- МТ — хороший пример аппаратной реализации `литерного типа`.

- Базовый тип — аппаратный тип. Железо бывает нежелезным(!). Сейчас оно микропрограммное.

МТ одновременно является и неудачным примером, ибо задание даже простейших алгебраических действий сильно затруднено.

Нам необходима эффективная практическая вычислимость.
Типы данных возникают чаще, чем железки.
- Почему мы это приветствуем?
- Это позволяет программировать сразу под конкретные классы задач.

> ***Целые числа*** — способ нумерации конечных множеств. Но в них нет смысла. Нужны имена!

***

## 3.2.2 Тип логический

![image](https://user-images.githubusercontent.com/113284506/211207165-f133ee4d-c376-4365-a678-5e1bbe509f24.png)


- bottom _ | _  это знак неопределённости. Он описывает незаданность значения.

![image](https://user-images.githubusercontent.com/113284506/211207191-d7bf5a03-d92c-4825-a597-c10c3185fe1e.png)


- На языках СУБД _ | _ обозначается как NULL
- SQL читается как Сиквел.

> Если в машинном слове хотя бы одна единица, то истина.

![image](https://user-images.githubusercontent.com/113284506/211207250-2aaff3b7-f60a-49a0-8470-37bd7b9693e6.png)


![image](https://user-images.githubusercontent.com/113284506/211207107-a1bb3926-2545-4ee1-8012-0ec766b0009a.png)

***

## 3.2.3 Тип целый

Из курса алгебры знаем — это множество целых чисел вида 0-+1+-2, образующих `алгебраическое кольцо`
относительно сложения и умножения (деление разрывает кольцо — 7/2 не является целым числом). 

Эффективная вычислимость требует замены бесконечного числа чисел на конечный отрезок (множество), в который войдут числа между MIN MAX.

- Кухонный процессор: [-32768; 32767].
- 0 входит в положительную часть, поэтому диапазон несимметричен.

- `Т` - переопределённое значение, депутат. Вместе с неопределённым значением `_ | _` они войдут в целый тип.

Унарный минус - взятие противоположного числа.
- Есть ещё и бинарный минус. Их надо различать.

> - Отношение в целом типе размыкает целый тип и переходит в булевский (введён в C99).
> - Раз отношения размыкают логический тип, то они не являются операциями (3/5).

Отношения являются операциями если в результате получается тот же тип данных. А рациональные числа - размыкание целого типа.

![image](https://user-images.githubusercontent.com/113284506/211207650-419ad88d-7228-42c5-bdfd-133d3c3d6519.png)

![image](https://user-images.githubusercontent.com/113284506/211207535-d79f9f36-dcb8-4961-b999-34193e1a1d76.png)

![image](https://user-images.githubusercontent.com/113284506/211207545-3b070f37-403c-409e-bccb-e06209c90fbd.png)


- Если указано множество и принадлежность элементов, то это условие неразмыкания кольца.

- Если X + Y - переполнение, то и результат переполнение.

- Отсутствие промежуточных результатов вычислений приводит к проблеме переполнения. Причина - ограниченность значений нарушения законов ассоциативности и дистрибутивности.

- Деление - медленная операция.

- Алгоритм деления - не алгоритм. В нём есть элемент прикидки, эвристического подбора.
Деление сводится к вычитанию с эвристическим подбором.

