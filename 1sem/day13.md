# 13 день. Критика фон Неймана, Pascal, рекурсия

## Словарик программиста (надо знать!):

- `Концептуальный` — сущностный, содержательный.
- `Рекурсия` — это углубляющееся многократное самоприменение.
- `Рекурсивная программа` — композиция из множества операторов, не содержащих самой программы.

***

## 3.4.4 Побочные эффекты

При использовании глобальных объектов в подпрограмме их значение может измениться после выполнения.

Подпрограмма, вычисляющая функцию, в результате должна получать новое значение.
Но изменение при этом глобальных переменных ***не являлось целью***, поэтому и называется `побочным эффектом`. 

Это проявляется и в изменении значений параметров функции, если способ их передачи был нежелателен.

![image](https://user-images.githubusercontent.com/113284506/211146209-c006697d-39e2-4d7e-9449-88208dec2b4b.png)

![image](https://user-images.githubusercontent.com/113284506/211146596-7fe87613-ab82-4fa3-a9f0-29b95b3ec02b.png)

![image](https://user-images.githubusercontent.com/113284506/211146603-90304bcc-44c7-42e6-aa7d-e27acf208baa.png)


***

## 3.4.5 Критика алгоритмической модели фон Неймана

`Модель фон Неймана` — развитие модели Тьюринга, математически точной и полезной, наделённой памятью и чувствительностью к предыстории.

> МТ работает на частой смене `простых состояний`, поэтому `программы неясные` и `концептуально бесполезные`.
> Построением диаграмм, схем, а также программ на языке ОСТ мы улучшили эту модель, но недостатки сохранились.

Только концепция модели фон Неймана оказалась полезной на практике.
К ней относят как `компьютеры`, так и `ЯП`.
- Они математически сложны и громоздки, существенно используют память и чувствительны к предыстории, как и МТ.
- Модель основана на переходах между более сложными `(в сравнении с МТ)` состояниями.
- При этом `ясность программ` и `концептуальная польза` оказывается `выше`.

- Компьютер фон-Неймана состоит из `процессора`, `памяти` и `шины`, передающей между ними одно слово за такт.
Это слово либо единица данных, либо команда, либо адрес.

Джон Бэкус называет шину ***«бутылочным горлышком»*** этой архитектуры.
Программа меняет содержимое памяти процессором посредством перекачки данных через шину из памяти и обратно. 
Но ***большую часть этого потока составляют команды и адреса***, а не полезные данные.

Перед отправлением слова через шину, его адрес появляется на процессоре. 
И появляется там либо через шину, либо генерируется на процессоре.
- Если `адрес` взят из памяти, то и `его адрес` посылается из памяти либо вырабаывается на процессоре.

Шина не только сужает место для потока команд и данных,
но и ограничивает в мышлении: программируем «слово за словом» вместо работы с крупными понятиями решаемой задачи.

`ЯП` — более сложные версии компьютера фон Неймана:
- Переменные имитируют ячейки памяти;
- операторы управления выражают команды управления и проверки;
- операторы присваивания имитируют загрузку содержимого ячейки и вычисления, запоминанают результат.

`Узкое место ЯП` — ***оператор присваивания***.

Он разделяет программирование на левый и правый миры:
- `Левая` — неупорядоченный мир операторов, существующих ради главного из них — оператора присваивания, выполняющего вычисления.
- `Правая` — мир полезных алгебраических вычислений (не учитывая их нарушения побочными эффектами).

Отсутствие иных стилей программирования сделало другие концепции неэкономичными, ограничив их развитие.
- Джон Бэкус предлагает ***функциональный стиль программирования***, основанный на рекурсивных построениях.

***

## 3.5 Критика языка Паскаль

```yaml
© Профессионализм в том, чтобы 
- критиковать вещи,
- которые сделаны хорошо.
```

Автор Паскаля, профессор Вирт, был удостоен Тьюринговской премии.

С этим ЯП связан ряд достижений систем программирования.

Это и `бутстрепинг` — постепенное написание компилятора для системного программирования,
и реализация `интерпретатора p-кода`, реализуемого за неделю на любом ЯП на новом компьютере. 

Недостатки этого ***замечательного языка*** являются продолжением его достоинств.

Паскаль представляет собой программно-компилируемую реализацию машины фон Неймана
и к нему можно отнести всю критику этой алгоритмической модели.

1) Скалярный оператор присваивания заставляет программиста постоянно заботиться о рациональном
его использовании и отвлекает от решения самой задачи.

2) Паскаль является строго типированным языком, а значит меньше вероятность написать плохую программу. При этом он прост:
всё описание программы в начале, но объекты программы употребляются в строгом соответствии с описаниями,
что неудобно в системном программировании.
 
3) В своей строгости Паскаль непоследователен.
Например, записи с вариантными частями образуют брешь в системе типизации.

Паскаль эффективно компилируется на аппаратуру.
Но это превращается в недостаток, т.к. многие типы данных (строки и массивы переменной длины)
либо не реализованы, либо их реализация наталкивается на ряд проблем.
> Поэтому едим 3 ножами и 5 вилками.


- На Си блочная структура, реализуемая через процедуры.
- При этом язык Си не так дуракоустойчив, как Pascal.
- `Си` — аскетичный язык. Он даёт небогатую среду в сравнение с диванным программированием на Python.

Паскаль проигрывает Си не только в выризительной силе и лаконичности.
Идеальная модель Паскаля далека от реальности:
- Отсутствие модульности и внешних процедур закрывает путь в товарное программирование 
- Да и сама библиотека языка Си — мощный интерпретируемый компонент.

***

## 5.8 Рекурсия (переход на с.258)

```yaml
А этот глист страдал глистами
- что мучились глистами сами!
```

- ***Рекурсивный объект*** определяется с помощью самого себя. 
Наглядный жизненный пример получим, если встанем между 2 зеркалами — увидим бесконечную последовательность отражений.

- `Рекурсивные определения` — математический аппарат, позволяющий `конструктивно` определить бесконечное множество объектов малым набором правил.

![image](https://user-images.githubusercontent.com/113284506/211149607-3a82dea7-75d2-4ac8-8917-f7e3b1a226a6.png)

Программы, как и функции могут быть заданы рекурсивно.
- `Рекурсивная программа` — композиция из множества операторов, не содержащих самой программы.

***Виды рекурсий***:
- `Прямая рекурсия` — вызов подпрограммой самой себя по имени, а `косвенная` — вызов одной через другую программу.

***Более сложная классификация рекурсий***:
- линейная
- повторная (концевая, хвостовая)
- каскадная
- удалённая
- взаимная

- `Рекурсивные вызовы` процедур производятся аналогично вызову одной процедуры из другой.
Просто в них все вызываемые процедуры одинаковы.

- Каждая рекурсивная активация блока порождает новую локальную переменную, а предыдущие одноименные откладываются в стек и экранируются.

- `Рекурсия` — это углубляющееся многократное самоприменение.
Мы прибегаем к рекурсии для автоматического упрощения задачи, которая, как и цикл, должна завершиться по выполнии.

Для этого внутри рекурсивного тела `Р` должно находиться условие завершения `В`, которое станет истинным.
Схему рекурсивных алгоритмов можно представить в одной из следующих форм:

![image](https://user-images.githubusercontent.com/113284506/211149272-e7fb19bb-2027-4804-98fb-46b4ac0b72a9.png)

![image](https://user-images.githubusercontent.com/113284506/211155689-8e2ac910-2e02-44da-a206-d4a5755c33d8.png)

> Следует добиваться конечной и малой повторяемости рекурсивных вычислений, иначе мы не получим выигрыш от красивого программирования.

![image](https://user-images.githubusercontent.com/113284506/211155273-2603511c-a050-4cc6-9f55-adfebfea6a96.png)

![image](https://user-images.githubusercontent.com/113284506/211149423-182f0b99-f96c-492f-a4df-189c2c38a952.png)

![image](https://user-images.githubusercontent.com/113284506/211149439-61b9c002-99d9-4040-8502-8a4b55866df1.png)

![image](https://user-images.githubusercontent.com/113284506/211149492-eaa842fa-a725-4ff1-9e74-790c5406f091.png)

![image](https://user-images.githubusercontent.com/113284506/211149514-07f10d6a-64a3-4677-96f2-916ff110f4d7.png)

![image](https://user-images.githubusercontent.com/113284506/211149537-bcc31c3f-c254-419c-a497-4b84bc23ce12.png)

![image](https://user-images.githubusercontent.com/113284506/211149544-06db3738-7dad-4ae3-9469-5c3825cd64cd.png)

![image](https://user-images.githubusercontent.com/113284506/211149552-2e71ff9a-5129-45b0-949a-424d479be7df.png)

- `Аккерман` — удалённо-рекурсивная функция. она захлёбывается в рекурсии. В цикл её не перепишешь.
- Функция завершима: все её аргументы уменьшаются, а она сама терминируется нулём.
